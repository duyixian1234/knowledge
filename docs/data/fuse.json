{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"个人知识库","n":1},"1":{"v":"\n记录我在工作和学习中掌握到的软件开发主题的知识。\n\n## 已完成\n\n![[个人介绍 | about me#简介:#*]]\n![[programming-languages.python#介绍:#*]]\n![[basic.software.operating-system#核心:#*]]\n\n## 施工中\n\n[[security]]\n","n":0.408}}},{"i":2,"$":{"0":{"v":"软件开发","n":1}}},{"i":3,"$":{"0":{"v":"Design","n":1}}},{"i":4,"$":{"0":{"v":"YAGNI","n":1}}},{"i":5,"$":{"0":{"v":"TDD","n":1}}},{"i":6,"$":{"0":{"v":"SOLID","n":1}}},{"i":7,"$":{"0":{"v":"KISS","n":1}}},{"i":8,"$":{"0":{"v":"Design Patterns","n":0.707}}},{"i":9,"$":{"0":{"v":"DRY","n":1}}},{"i":10,"$":{"0":{"v":"Config","n":1}}},{"i":11,"$":{"0":{"v":"Toml","n":1}}},{"i":12,"$":{"0":{"v":"Tools","n":1}}},{"i":13,"$":{"0":{"v":"Editor","n":1}}},{"i":14,"$":{"0":{"v":"Visual Studio Code","n":0.577}}},{"i":15,"$":{"0":{"v":"重构","n":1}}},{"i":16,"$":{"0":{"v":"Mobile Application","n":0.707}}},{"i":17,"$":{"0":{"v":"前端","n":1}}},{"i":18,"$":{"0":{"v":"Dev Ops","n":0.707}}},{"i":19,"$":{"0":{"v":"Desktop Application","n":0.707}}},{"i":20,"$":{"0":{"v":"Command Line Tools","n":0.577}}},{"i":21,"$":{"0":{"v":"Mordern Unix Tools","n":0.577},"1":{"v":"\n## bat\n\n## exa\n\n## fd-find\n\n## gitui\n\n## httpie\n\n## iredis\n\n## miniserve\n\n## procs\n\n## ripgrep\n\n## tokei\n","n":0.302}}},{"i":22,"$":{"0":{"v":"Core Utils","n":0.707}}},{"i":23,"$":{"0":{"v":"VCS","n":1}}},{"i":24,"$":{"0":{"v":"git","n":1}}},{"i":25,"$":{"0":{"v":"Testing","n":1}}},{"i":26,"$":{"0":{"v":"Unit Testing","n":0.707}}},{"i":27,"$":{"0":{"v":"持续集成","n":1}}},{"i":28,"$":{"0":{"v":"持续部署","n":1}}},{"i":29,"$":{"0":{"v":"API","n":1}}},{"i":30,"$":{"0":{"v":"gRPC","n":1}}},{"i":31,"$":{"0":{"v":"REST","n":1}}},{"i":32,"$":{"0":{"v":"Open API Spec","n":0.577}}},{"i":33,"$":{"0":{"v":"GraphQL","n":1}}},{"i":34,"$":{"0":{"v":"Authentication","n":1}}},{"i":35,"$":{"0":{"v":"信息安全","n":1},"1":{"v":"\n## 定义\n\n保护信息和信息系统免受未经授权的访问、使用、泄露、破坏、篡改或毁坏\n\n## 常见的安全风险\n\n- 未安装安全补丁程序或更新程序\n- 使用弱密码\n- 从互联网下载和运行未知程序\n- 打开来自不明发件人的电子邮件附件\n- 使用未加密的无线网络\n\n## CIA 三要素\n\n![安全三要素](https://res.weread.qq.com/wrepub/CB_3300018983_016-01.jpg)\n\n### 机密性（Confidentiality）\n\n机密性是指保护我们的数据不被未经授权的人查看的能力。\n\n### 完整性（Integrity）\n\n完整性是防止他人以未经授权或不受欢迎的方式更改数据的能力。\n\n### 可用性（Availability）\n\n可用性是指在需要时访数据的能力。\n\n## 攻击\n\n### 攻击类型\n\n#### 拦截\n\n> 拦截攻击允许未经授权的用户访问数据、应用程序或环境，这种攻击主要针对机密性的攻击。拦截的形式可能包括未经授权的查看或复制文件、窃听通话或读取他人的电子邮件。\n\n#### 中断\n\n> 中断攻击会使你的资产暂时或永久无法使用。这些攻击通常会影响可用性，也会影响完整性。你可以把邮件服务器 DoS 攻击归类为可用性攻击。\n\n#### 篡改\n\n> 篡改攻击涉及资产篡改。这类攻击主要是对完整性的攻击，但也可视为对可用性的攻击。如果以未经授权的方式访问文件并更改其中的数据，则会影响文件数据的完整性。但是，如果文件是管理服务行为的配置文件（如作为 Web 服务器的文件），则更改文件的内容可能会影响该服务的可用性。如果你在 Web 服务的文件中更改配置，导致服务处理加密连接的方式发生改变，你甚至可以称之为对机密性的攻击。\n\n#### 伪造\n\n> 伪造攻击涉及使用系统生成的数据、流程、通信或其他类似的资料。与后两种攻击类型一样，伪造攻击主要影响完整性，但也可能影响可用性。在数据库中生成虚假信息就是一种伪造攻击。你也可以生成电子邮件，这是传播恶意软件的常用方法。如果你生成足够多的额外进程、网络流量、电子邮件、Web 流量或任何其他消耗资源的东西，就可以使处理这类流量的服务无法由合法用户使用，从而进行可用性攻击。\n\n### 威胁、漏洞和风险\n\n> 威胁是指有可能造成损害的东西。威胁往往倾向于在特定环境下发生，特别是在信息安全领域。例如，一种病毒可能对 Windows 操作系统有影响，但不太可能对 Linux 操作系统产生影响。\n\n> 漏洞是指弱点或脆弱性，威胁可以利用漏洞给你造成伤害。\n\n> 风险是指坏事发生的可能性。要想使环境中出现风险，需要同时拥有威胁和可利用的漏洞。\n\n### 风险管理\n\n- 确定资产\n- 识别威胁\n- 评估漏洞\n- 评估风险\n- 缓解风险\n\n### 事件响应\n\n- 准备\n- 检测和分析\n- 遏制、清除和恢复\n- 事后活动\n\n### 纵深防御\n\n![纵深防御](https://res.weread.qq.com/wrepub/CB_3300018983_028-01.jpg)\n\n#### 分层防御\n\n![外部网络](https://res.weread.qq.com/wrepub/CB_3300018983_029-01.jpg)\n![内部网络](https://res.weread.qq.com/wrepub/CB_3300018983_030-01.jpg)\n![数据](https://res.weread.qq.com/wrepub/CB_3300018983_031-01.jpg)\n\n## 资源\n\n![[resources.books#信息安全:#*]]\n","n":0.139}}},{"i":36,"$":{"0":{"v":"身份识别与身份验证","n":1},"1":{"v":"\n## 概念\n\n> 身份识别是声称某人或某物是什么，而身份验证则确定该声明是否属实。\n\n## 身份识别\n\n- 声称自己是谁\n- 身份证实\n- 伪造身份\n\n## 身份验证\n\n- 因子\n- 多因子身份验证\n- 双向验证（中间人攻击）\n\n## 常见的身份识别和身份验证方法\n\n### 密码\n\n- 强密码\n- 密码管理器\n\n### 生物识别\n\n#### 生物识别因子特征\n\n- 普遍性\n- 唯一性\n- 恒久性\n- 易采集性\n- 系统性能\n- 可接受性\n- 防欺骗性\n\n#### 性能衡量\n\n- 错误接受率（False Acceptance Rate，FAR）\n- 错误拒绝率（False Rejection Rate，FRR）\n- 等错误率（Equal Error Rate，EER）\n\n![FAR-FRR-EER](https://res.weread.qq.com/wrepub/CB_3300018983_042-01.jpg)\n\n### 硬件令牌\n","n":0.169}}},{"i":37,"$":{"0":{"v":"OWASP","n":1}}},{"i":38,"$":{"0":{"v":"HTTPS","n":1}}},{"i":39,"$":{"0":{"v":"授权与访问控制","n":1},"1":{"v":"\n## 概念\n\n> 授权是指准确确定被验证方可以做什么的过程。访问控制是用于拒绝或允许访问的工具和系统，通常通过访问控制来实现授权。\n\n## 访问控制\n\n### 基本任务\n\n- 允许访问\n- 拒绝访问\n- 限制访问（沙箱）\n- 撤销访问\n\n## 实施访问控制\n\n### 访问控制表（Access Control List，ACL）\n\n- 文件系统访问控制表\n- 网络访问控制列表\n\n### 基于能力（令牌）的访问控制\n\n## 访问控制模型\n\n- 自主访问控制（Discretionary Access Control，DAC）\n- 强制访问控制（Mandatory Access Control，MAC）\n- 基于规则的访问控制（rule-based access control）\n- 基于角色的访问控制（Role-Based Access Control，RBAC）\n- 基于属性的访问控制（Attribute-Based Access Control，ABAC）（验证码 CAPTCHA）\n- 多级访问控制（multilevel access control）模型\n\n> 最小权限原则\n>\n> 最小权限原则规定，你应该只给一方执行功能所需的最低访问等级。例如，组织销售部门的人员完成工作，应该无须访问组织人力资源系统中的数据。违反最小权限原则是当今许多安全问题的根源。\n\n## 物理访问控制\n\n- 尾随\n- 安检\n- 围栏\n","n":0.154}}},{"i":40,"$":{"0":{"v":"审计和问责","n":1},"1":{"v":"\n## 问责\n\n> 为了让人们对自己的行为负责，必须对环境中的所有活动进行追踪溯源。这意味着必须使用身份识别、身份验证和授权过程，以便了解与事件相关联的人员及其执行该事件的权限。\n\n### 问责的安全效益\n\n- 不可否认性\n- 威慑\n- 入侵检测与防御\n- 记录的可接受性\n\n## 审计\n\n> 审计是对一个组织的记录进行有系统的检查和审查。在几乎任何环境中，从最低等级的技术到最高等级的技术，通常都会通过使用某种审计来确保人们对其行为负责。\n\n### 审计对象\n\n- 密码\n- 软件许可证\n\n### 日志记录\n\n- 记录关键事件\n- 定期检查\n- 日志分析\n\n### 监视\n\n- 异常与告警\n\n### 审计与评估\n\n- 漏洞评估\n- 渗透测试\n","n":0.213}}},{"i":41,"$":{"0":{"v":"资源","n":1}}},{"i":42,"$":{"0":{"v":"Sites","n":1},"1":{"v":"\n## Python\n\n- [Full Stack Python](https://www.fullstackpython.com/)\n- [Python behind the scenes](https://tenthousandmeters.com/tag/python-behind-the-scenes/)\n- [Real Python](https://realpython.com/)\n- [Python Weekly](https://us2.campaign-archive.com/home/?u=e2e180baf855ac797ef407fc7&id=9e26887fc5)\n- [Tag: Python | 那时难决 (duyixian.cn)](https://www.duyixian.cn/tags/Python/)\n","n":0.236}}},{"i":43,"$":{"0":{"v":"Links","n":1},"1":{"v":"\n## Python\n\n- [Building Large Scale Systems and Products with Python | Soroco Engineering](https://engineering.soroco.com/building-large-scale-systems-and-products-with-python/)\n- [A deep dive into the “official” Docker image for Python (pythonspeed.com)](https://pythonspeed.com/articles/official-python-docker-image/)\n","n":0.204}}},{"i":44,"$":{"0":{"v":"Learn","n":1},"1":{"v":"\n## Python\n\n- [面向初学者的 Python - Learn | Microsoft Docs](https://docs.microsoft.com/zh-cn/learn/paths/beginner-python/)\n- [通过 Python 构建真实的应用程序 - Learn | Microsoft Docs](https://docs.microsoft.com/zh-cn/learn/paths/python-language/)\n","n":0.243}}},{"i":45,"$":{"0":{"v":"Books","n":1},"1":{"v":"\n## 基础\n\n- [普林斯顿计算机公开课-布莱恩 W. 柯尼汉](https://weread.qq.com/web/bookDetail/6df32da0719710e26dfd7fe)\n\n## Python\n\n- [流畅的 Python-卢西亚诺·拉马略](https://weread.qq.com/web/bookDetail/ab832620715c017eab864a6)\n\n## Ansible\n\n- [Ansible 权威指南-李松涛 魏巍 甘捷](https://weread.qq.com/web/bookDetail/975321605ce6489759ea594)\n\n## Flask\n\n- [Flask Web 开发：基于 Python 的 Web 应用开发实战（第 2 版）-米格尔·格林贝格](https://weread.qq.com/web/bookDetail/6c632420718ff5d76c6bd79)\n- [Flask Web 开发实战：入门、进阶与原理解析-李辉](https://weread.qq.com/web/bookDetail/26132b70715ec2fd26119ee)\n\n## Django\n\n- [Django：Web Development with Python-Samuel Dauzon Aidas Bendoraitis Arun Ravindran](https://weread.qq.com/web/bookDetail/1e332a70723006f81e377bf)\n\n## 操作系统\n\n- [操作系统导论-雷姆兹·H.阿帕希杜塞尔 安德莉亚·C.阿帕希杜塞尔](https://weread.qq.com/web/bookDetail/db8329d071cc7f70db8a479)\n\n## 信息安全\n\n- [信息安全精要：从概念到安全性评估-杰森·安德鲁斯](https://weread.qq.com/web/bookDetail/2c232340813ab6deag013132)\n","n":0.156}}},{"i":46,"$":{"0":{"v":"编程语言","n":1}}},{"i":47,"$":{"0":{"v":"TypeScript","n":1}}},{"i":48,"$":{"0":{"v":"Rust","n":1}}},{"i":49,"$":{"0":{"v":"Python","n":1},"1":{"v":"\n## 介绍\n\n[Python 教程](https://docs.python.org/zh-cn/3/tutorial/index.html)\n\n> Python 是一门易于学习、功能强大的编程语言。它提供了高效的高级数据结构，还能简单有效地面向对象编程。Python 优雅的语法和动态类型以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的理想语言。\n\n## 特点\n\n- 语法简洁，代码可读性强，易于学习\n- 功能强大，支持多种编程范式（ [[programming-languages.Structural Programming]]，[[programming-languages.Object Orinted Programming]]，[[programming-languages.functional programming]],[[programming-languages.meta programming]] ）\n- 丰富的内置函数和模块\n- 易于扩展（[扩展和嵌入 Python 解释器](https://docs.python.org/zh-cn/3/extending/index.html#extending-index)）\n- 具有活跃的社区和强大的生态\n\n## 应用\n\n- 编写服务端脚本和命令行程序（ [[programming-languages.python.click]]，[[programming-languages.python.typer]] ）\n- 运维/DevOps([[programming-languages.python.Ansible]])\n- 爬虫（[[programming-languages.python.requests]]，[[programming-languages.python.playwright]]，[[programming-languages.python.scrapy]] ）\n- 大数据/机器学习（ [[programming-languages.python.numpy]]，[[programming-languages.python.pandas]]，[[programming-languages.python.Tensorflow]]，[[programming-languages.python.Pytorch]] ）\n- 后端服务开发（ [[programming-languages.python.Flask]]，[[programming-languages.python.Django]]，[[programming-languages.python.FastAPI]] ）\n- 客户端应用程序开发（[[programming-languages.python.PyQT5]]）\n\n## Python 之禅\n\n![[Python之禅 | programming-languages.python.Zen of Python#内容:#*]]\n\n## 语言特性\n\n- [[programming-languages.python.builtin types]]\n- [[programming-languages.python.builtin functions]]\n- [[programming-languages.python.type hints]]\n- [[programming-languages.python.modules]]\n- [[programming-languages.python.iterators]]\n- [[programming-languages.python.generators]]\n- [[programming-languages.python.list comprehension]]\n- [[programming-languages.python.decorators]]\n- [[programming-languages.python.context manager]]\n- [[programming-languages.python.structral pattern match]]\n\n## 第三方库\n\n- [Pypi](https://pypi.org/)\n- [[programming-languages.python.pip]]\n- [[programming-languages.python.poetry]]\n\n## 虚拟环境\n\n- [[programming-languages.python.venv]]\n- [[programming-languages.python.pipenv]]\n\n## 并发\n\n- [[programming-languages.python.multithreading]]\n- [[programming-languages.python.gevent]]\n- [[programming-languages.python.asyncio]]\n\n## 资源\n\n![[resources.books#Python:#*]]\n![[resources.learn#Python:#*]]\n![[resources.sites#Python:#*]]\n![[resources.links#Python:#*]]\n","n":0.119}}},{"i":50,"$":{"0":{"v":"Venv","n":1},"1":{"v":"\n## 创建虚拟环境\n\n```shell\nubuntu:tmp/ $ python -m venv .venv                                                                           [20:35:41]\nubuntu:tmp/ $ ls -l -a                                                                                       [20:35:49]\n总用量 12\ndrwxrwxr-x  3 ubuntu ubuntu 4096 8月  13 20:35 .\ndrwxr-xr-x 43 ubuntu ubuntu 4096 8月  13 20:35 ..\ndrwxrwxr-x  5 ubuntu ubuntu 4096 8月  13 20:35 .venv\n```\n\n## 激活虚拟环境\n\n```shell\nubuntu:tmp/ $ source .venv/bin/activate                                                                      [20:37:29]\n(.venv) ubuntu:tmp/ $ which python                                                                           [20:38:01]\n/home/ubuntu/tmp/.venv/bin/python\n(.venv) ubuntu:tmp/ $                                                                                        [20:38:07]\n```","n":0.14}}},{"i":51,"$":{"0":{"v":"Typer","n":1},"1":{"v":"\n## 介绍\n\n[typer](https://pypi.org/project/typer/)是[[programming-languages.python.click]]的类型提示版本。\n\n> Typer is a library for building CLI applications that users will **love using** and developers will **love creating** . Based on Python 3.6+ type hints.\n>\n> The key features are:\n>\n> - **Intuitive to write** : Great editor support. Completion everywhere. Less time debugging. Designed to be easy to use and learn. Less time reading docs.\n> - **Easy to use** : It's easy to use for the final users. Automatic help, and automatic completion for all shells.\n> - **Short** : Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs.\n> - **Start simple** : The simplest example adds only 2 lines of code to your app: **1 import, 1 function call** .\n> - **Grow large** : Grow in complexity as much as you want, create arbitrarily complex trees of commands and groups of subcommands, with options and arguments.\n","n":0.085}}},{"i":52,"$":{"0":{"v":"Type Hints","n":0.707},"1":{"v":"\n## 介绍\n\n[typing —— 类型注解支持 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/library/typing.html#module-typing)\n\n## 应用场景\n\n- IDE 提示（ [[software-develop.tools.editor.Visual Studio Code]] ）\n- 静态分析（ [[programming-languages.python.mypy]] ）\n- 运行时获取类型信息（ [[programming-languages.python.modules#dataclasses]] [[programming-languages.python.pydantic]] [[programming-languages.python.FastAPI]] ）\n","n":0.209}}},{"i":53,"$":{"0":{"v":"结构化模式匹配","n":1},"1":{"v":"\n## 介绍\n\n[Python 3.10 中的模式匹配 | 那时难决 (duyixian.cn)](https://www.duyixian.cn/2021/03/19/Structural%20Pattern%20Matching%20In%20Python%203.10/)\n\n## 示例\n\n```python\n# 快速排序的一个概念性实现\ndef quicksort(arr: list[int]) -> list[int]:\n    match arr:\n        case first,:\n            return [first]\n        case first, second:\n            return [first, second] if first <= second else [second, first]\n        case first, *rest:\n            return (\n                quicksort([num for num in rest if num <= first])\n                + [first]\n                + quicksort([num for num in rest if num > first])\n            )\n```\n","n":0.13}}},{"i":54,"$":{"0":{"v":"Scrapy","n":1},"1":{"v":"\n## 介绍\n\n[Scrapy](https://pypi.org/project/Scrapy/)是一个 Python 爬虫框架。\n","n":0.5}}},{"i":55,"$":{"0":{"v":"Requests","n":1},"1":{"v":"\n## 介绍\n\n[requests](https://pypi.org/project/requests/)是一个 Python 的 HTTP 请求库，提供了简单、优雅的接口。\n\n```python\n>>> import requests\n>>> r = requests.get('https://httpbin.org/basic-auth/user/pass', auth=('user', 'pass'))\n>>> r.status_code\n200\n>>> r.headers['content-type']\n'application/json; charset=utf8'\n>>> r.encoding\n'utf-8'\n>>> r.text\n'{\"authenticated\": true, ...'\n>>> r.json()\n{'authenticated': True, ...}\n```\n","n":0.209}}},{"i":56,"$":{"0":{"v":"Pydantic","n":1}}},{"i":57,"$":{"0":{"v":"Poetry","n":1},"1":{"v":"\n## 简介\n\n[Poetry](https://python-poetry.org/)是一个基于pyproject.toml的工具，利用poetry可以更加方便地进行 Python 项目的开发、构建、发布和依赖管理。\n\n## 使用\n\n参考文章[使用poetry进行Python项目开发](https://www.duyixian.cn/2020/11/23/poetry/)","n":0.447}}},{"i":58,"$":{"0":{"v":"Playwright","n":1},"1":{"v":"\n## 介绍\n\n[playwright](https://pypi.org/project/playwright/)是一个 Python 浏览器自动化工具，支持不同操作系统下的多款浏览器。\n\n|                        | Linux | macOS | Windows |\n| :--------------------- | :---: | :---: | :-----: |\n| Chromium 105.0.5195.19 |  ✅   |  ✅   |   ✅    |\n| WebKit 16.0            |  ✅   |  ✅   |   ✅    |\n| Firefox 103.0          |  ✅   |  ✅   |   ✅    |\n\n## 使用\n\n### 同步接口\n\n```python\nfrom playwright.sync_api import sync_playwright\n\nwith sync_playwright() as p:\n    for browser_type in [p.chromium, p.firefox, p.webkit]:\n        browser = browser_type.launch()\n        page = browser.new_page()\n        page.goto('http://whatsmyuseragent.org/')\n        page.screenshot(path=f'example-{browser_type.name}.png')\n        browser.close()\n```\n\n### 异步接口\n\n```python\nimport asyncio\nfrom playwright.async_api import async_playwright\n\nasync def main():\n    async with async_playwright() as p:\n        for browser_type in [p.chromium, p.firefox, p.webkit]:\n            browser = await browser_type.launch()\n            page = await browser.new_page()\n            await page.goto('http://whatsmyuseragent.org/')\n            await page.screenshot(path=f'example-{browser_type.name}.png')\n            await browser.close()\n\nasyncio.run(main())\n```\n","n":0.1}}},{"i":59,"$":{"0":{"v":"Pipenv","n":1},"1":{"v":"\n## 介绍\n\n[pipenv](https://pypi.org/project/pipenv/)是一个 Python 虚拟环境与包管理工具。可以理解为一个 Python 版本的 npm。\n\npipenv使用Pipfile定义项目的元信息（依赖，Python版本等）。\n\nPipfile使用[[software-develop.config.toml]]格式，下面是一个典型的[Pipfile](https://github.com/duyixian1234/fastapi-template/blob/master/Pipfile)的内容。\n\n```toml\n[[source]] # 设置pypi源信息\nurl = \"https://mirrors.tencent.com/pypi/simple\"\nverify_ssl = true\nname = \"pypi\"\n\n[packages] # 维护依赖\nfastapi = \"*\"\nuvicorn = \"*\"\nuvloop = \"*\"\nhttptools = \"*\"\n\n[dev-packages] # 维护开发依赖\npylint = \"*\"\nisort = \"*\"\nmypy = \"*\"\npytest = \"*\"\npytest-cov = \"*\"\nblack = \"*\"\nrequests = \"*\"\n\n[requires] # 指定Python版本\npython_version = \"3.9\"\n\n[pipenv] # 额外设置\nallow_prereleases = true\n\n```","n":0.143}}},{"i":60,"$":{"0":{"v":"Pip","n":1},"1":{"v":"\n## 升级 pip\n\n```shell\n$ python -m pip install -U pip\n```\n\n## 指定 Pypi 源\n\n### 镜像地址\n\n| 镜像   | 地址                                          |\n| ------ | --------------------------------------------- |\n| 豆瓣   | https://pypi.doubanio.com/simple/             |\n| 阿里云 | https://mirrors.aliyun.com/pypi/simple        |\n| 腾讯云 | https://mirrors.cloud.tencent.com/pypi/simple |\n\n### 安装时指定\n\n```shell\n$ pip install flask -i https://mirrors.tencent.com/pypi/simple\n```\n\n### 修改 requirements.txt\n\n第一行加入`-i https://mirrors.tencent.com/pypi/simple`\n\n### 设置为默认值\n\n修改`$HOME/.config/pip/pip.conf`\n\n```ini\n[global]\ntimeout = 60\nindex-url = https://pypi.doubanio.com/simple/\nNPM\n```\n","n":0.146}}},{"i":61,"$":{"0":{"v":"Pandas","n":1},"1":{"v":"\n## 介绍\n\n[Pandas](https://pypi.org/project/pandas/)是一个强大的 Python 数据分析库。\n\n> ## Main Features\n>\n> Here are just a few of the things that pandas does well:\n>\n> - Easy handling of [**missing data**](https://pandas.pydata.org/pandas-docs/stable/user_guide/missing_data.html) (represented as `NaN`, `NA`, or `NaT`) in floating point as well as non-floating point data\n> - Size mutability: columns can be [**inserted and deleted**](https://pandas.pydata.org/pandas-docs/stable/user_guide/dsintro.html#column-selection-addition-deletion) from DataFrame and higher dimensional objects\n> - Automatic and explicit [**data alignment**](https://pandas.pydata.org/pandas-docs/stable/user_guide/dsintro.html?highlight=alignment#intro-to-data-structures): objects can be explicitly aligned to a set of labels, or the user can simply ignore the labels and let `Series`, `DataFrame`, etc. automatically align the data for you in computations\n> - Powerful, flexible [**group by**](https://pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html#group-by-split-apply-combine) functionality to perform split-apply-combine operations on data sets, for both aggregating and transforming data\n> - Make it [**easy to convert**](https://pandas.pydata.org/pandas-docs/stable/user_guide/dsintro.html#dataframe) ragged, differently-indexed data in other Python and NumPy data structures into DataFrame objects\n> - Intelligent label-based [**slicing**](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#slicing-ranges), [**fancy indexing**](https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html#advanced), and [**subsetting**](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#boolean-indexing) of large data sets\n> - Intuitive [**merging**](https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html#database-style-dataframe-or-named-series-joining-merging) and [**joining**](https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html#joining-on-index) data sets\n> - Flexible [**reshaping**](https://pandas.pydata.org/pandas-docs/stable/user_guide/reshaping.html) and [**pivoting**](https://pandas.pydata.org/pandas-docs/stable/user_guide/reshaping.html) of data sets\n> - [**Hierarchical**](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#hierarchical-indexing-multiindex) labeling of axes (possible to have multiple labels per tick)\n> - Robust IO tools for loading data from [**flat files**](https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#csv-text-files) (CSV and delimited), [**Excel files**](https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#excel-files), [**databases**](https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#sql-queries), and saving/loading data from the ultrafast [**HDF5 format**](https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables)\n> - [**Time series**](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#time-series-date-functionality)-specific functionality: date range generation and frequency conversion, moving window statistics, date shifting and lagging\n","n":0.069}}},{"i":62,"$":{"0":{"v":"Numpy","n":1},"1":{"v":"\n## 介绍\n\n[numpy](https://pypi.org/project/numpy/)是一个 Python 数值计算库，用于高效处理多维数组数据。\n\n> Project description\n>\n> It provides:\n>\n> - a powerful N-dimensional array object\n> - sophisticated (broadcasting) functions\n> - tools for integrating C/C++ and Fortran code\n> - useful linear algebra, Fourier transform, and random number capabilities\n> - and much more\n>\n> Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data. Arbitrary data-types can be defined. This allows NumPy to seamlessly and speedily integrate with a wide variety of databases.\n>\n> All NumPy wheels distributed on PyPI are BSD licensed.\n>\n> NumPy requires pytest and hypothesis. Tests can then be run after installation with:\n>\n> ```\n> python -c 'import numpy; numpy.test()'\n> ```\n","n":0.097}}},{"i":63,"$":{"0":{"v":"Mypy","n":1}}},{"i":64,"$":{"0":{"v":"Multithreading","n":1},"1":{"v":"\n## [GIL](https://docs.python.org/zh-cn/3/glossary.html#term-global-interpreter-lock)\n\n> 在 CPython 中，由于存在 全局解释器锁，同一时刻只有一个线程可以执行 Python 代码（虽然某些性能导向的库可能会去除此限制）。 如果你想让你的应用更好地利用多核心计算机的计算资源，推荐你使用 multiprocessing 或 concurrent.futures.ProcessPoolExecutor。 但是，如果你想要同时运行多个 I/O 密集型任务，则多线程仍然是一个合适的模型。\n\n## Python多线程\n\n### threading标准库\n\n可以使用threading标准库的Thread类创建并管理线程，相对而言比较繁琐。\n\n### ThreadPoolExecutor\n\nconcurrent.futures 标准库提供了ThreadPoolExecutor类型，可以方便创建和使用线程池。\n\n#### 示例\n\n```python\nimport time\nimport requests\nfrom functools import partial\nfrom concurrent.futures import ThreadPoolExecutor\n\ndef fetch(url:str, session: requests.Session) -> int:\n    resp = session.get(url)\n    return resp.status_code\n\nwith requests.Session() as session:\n    start = time.time()\n    for x in range(100):\n        fetch(f'http://httpbin.org/get?a={x}', session) \n    print(f'For Loop Cost: {time.time()-start} seconds')\n\n# For Loop Cost: 26.713851928710938 seconds\n\nwith ThreadPoolExecutor() as pool,requests.Session() as session:\n    fetch_with_session = partial(fetch, session = session)\n    start = time.time()\n    list(pool.map(fetch_with_session, [f'http://httpbin.org/get?a={x}' for x in range(100)]))\n    print(f'ThreadPoolExecutor Cost: {time.time()-start} seconds')\n\n# ThreadPoolExecutor Cost: 3.781949758529663 seconds\n```","n":0.106}}},{"i":65,"$":{"0":{"v":"标准库模块","n":1},"1":{"v":"\n参考[Python 标准库](https://docs.python.org/zh-cn/3/library/index.html)\n\n## math\n\n实用的数学函数\n\n## collections\n\n提供了一些有用的容器类\n\n## functools\n\n提供了一些有用的高阶函数\n\n## itertools\n\n提供了大量的函数用于处理和生成迭代器\n\n## heapq\n\n提供了原生的二叉堆算法\n\n## bisect\n\n数组二分查找算法\n\n## dataclasses\n\n利用 Type Hint 定义数据类\n\n## pathlib\n\n优雅的文件路径处理库\n","n":0.277}}},{"i":66,"$":{"0":{"v":"列表（字典， 集合）推导式","n":0.707},"1":{"v":"\n## 基本用法\n\n```python\nassert [x for x in range(10) if x % 2] == [1, 3, 5, 7, 9]\nassert {x for x in range(10) if x % 2} == {1, 3, 5, 7, 9}\nassert {x: x**2 for x in range(10)} == {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}\n```\n\n## 内部实现\n\n使用`get_iter`指令，效率高于 map/filter 函数\n\n```python\n>>> import dis\n>>> dis.dis(\"[x for x in 'abc']\")\n1           0 LOAD_CONST               0 (<code object <listcomp> at 0x000001F3D5502E40, file \"<dis>\", line 1>)\n              2 LOAD_CONST               1 ('<listcomp>')\n              4 MAKE_FUNCTION            0\n              6 LOAD_CONST               2 ('abc')\n              8 GET_ITER\n             10 CALL_FUNCTION            1\n             12 RETURN_VALUE\n\nDisassembly of <code object <listcomp> at 0x000001F3D5502E40, file \"<dis>\", line 1>:\n  1           0 BUILD_LIST               0\n              2 LOAD_FAST                0 (.0)\n        >>    4 FOR_ITER                 4 (to 14)\n              6 STORE_FAST               1 (x)\n              8 LOAD_FAST                1 (x)\n             10 LIST_APPEND              2\n             12 JUMP_ABSOLUTE            2 (to 4)\n        >>   14 RETURN_VALUE\n```\n\n```python\n>>> import timeit\ncomprehension = timeit.timeit(\"[x.upper() for x in 'abc']\", number=10000)\nmap_function = timeit.timeit(\"list(map(str.upper, 'abc'))\", number=10000)\nprint(f'{comprehension=} vs {map_function=}')\n\ncomprehension=0.003946700002416037 vs map_function=0.0069931999896653\n```\n","n":0.079}}},{"i":67,"$":{"0":{"v":"迭代器","n":1},"1":{"v":"\n## 简介\n\n[迭代器类型](https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator-types)\n\n## 创建迭代器\n\n- iter 函数\n- [[programming-languages.python.modules#itertools]]\n","n":0.408}}},{"i":68,"$":{"0":{"v":"Gevent","n":1},"1":{"v":"## 介绍\n\n[gevent](https://pypi.org/project/gevent/)是一个基于协程的Python网络库。\n\n> gevent is a [coroutine](https://en.wikipedia.org/wiki/Coroutine) -based [Python](http://python.org/) networking library that uses [greenlet](https://greenlet.readthedocs.io/) to provide a high-level synchronous API on top of the [libev](http://software.schmorp.de/pkg/libev.html) or [libuv](http://libuv.org/) event loop.\n>\n> Features include:\n>\n> * Fast event loop based on [libev](http://software.schmorp.de/pkg/libev.html) or [libuv](http://libuv.org/).\n> * Lightweight execution units based on greenlets.\n> * API that re-uses concepts from the Python standard library (for examples there are [events](http://www.gevent.org/api/gevent.event.html#gevent.event.Event) and [queues](http://www.gevent.org/api/gevent.queue.html#gevent.queue.Queue)).\n> * [Cooperative sockets with SSL support](http://www.gevent.org/api/index.html#networking)\n> * [Cooperative DNS queries](http://www.gevent.org/dns.html) performed through a threadpool, dnspython, or c-ares.\n> * [Monkey patching utility](http://www.gevent.org/intro.html#monkey-patching) to get 3rd party modules to become cooperative\n> * TCP/UDP/HTTP servers\n> * Subprocess support (through [gevent.subprocess](http://www.gevent.org/api/gevent.subprocess.html#module-gevent.subprocess))\n> * Thread pools\n>\n> gevent is [inspired by eventlet](http://blog.gevent.org/2010/02/27/why-gevent/) but features a more consistent API, simpler implementation and better performance. Read why others [use gevent](http://groups.google.com/group/gevent/browse_thread/thread/4de9703e5dca8271) and check out the list of the [open source projects based on gevent](https://github.com/gevent/gevent/wiki/Projects).\n\n## 应用\n\n- gunicorn\n- celery\n","n":0.085}}},{"i":69,"$":{"0":{"v":"生成器","n":1},"1":{"v":"\n## 介绍\n\n[生成器类型](https://docs.python.org/zh-cn/3/library/stdtypes.html#generator-types)\n\n## yield 表达式\n\n[yield 表达式](https://docs.python.org/zh-cn/3/reference/expressions.html#yield-expressions)\n\n## 特点\n\n- 惰性计算\n- 节省内存\n\n## 示例\n\n```python\nimport itertools\n\n\ndef fib():\n    a, b = 1, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\nassert list(itertools.takewhile(lambda x: x < 100, fib())) == [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n```\n","n":0.149}}},{"i":70,"$":{"0":{"v":"装饰器","n":1},"1":{"v":"\n## 介绍\n\n> decorator -- 装饰器返回值为另一个函数的函数，通常使用 `@wrapper` 语法形式来进行函数变换。装饰器的常见例子包括 `classmethod` 和 `staticmethod`。\n>\n> 装饰器语法只是一种语法糖，以下两个函数定义在语义上完全等价:\n>\n> ```python\n> def f(arg):\n>     ...\n> f = staticmethod(f)\n>\n> @staticmethod\n> def f(arg):\n>     ...\n> ```\n\n## 示例\n\n```python\ndef log_call(func):\n    def wrapper(*args, **kwargs):\n        print(f'Function {func.__name__} Called With ({args}, {kwargs})')\n        return func(*args, **kwargs)\n    return wrapper\n\n@log_call\ndef add(x, y):\n    return x + y\n\nassert add(1, 2) == 3 # Function add Called With ((1, 2), {})\n```\n","n":0.132}}},{"i":71,"$":{"0":{"v":"上下文管理器","n":1},"1":{"v":"\n## 介绍\n\n[RAII 概念与在 Python 中的应用 | 那时难决 (duyixian.cn)](https://www.duyixian.cn/2021/08/22/RAII/)\n\n## 示例\n\n```python\nclass MyContextManager:\n    def __init__(self):\n        self.used = False\n    def __enter__(self):\n        print('entering')\n        self.used = True\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print('exiting')\n\nwith MyContextManager() as cm:\n    print('in context')\n    assert cm.used\n```\n","n":0.167}}},{"i":72,"$":{"0":{"v":"Click","n":1},"1":{"v":"\n## 介绍\n\n[click](https://pypi.org/project/click/)是一个用于开发命令行程序的 Python 包。\n\n> Click is a Python package for creating beautiful command line interfaces in a composable way with as little code as necessary. It’s the “Command Line Interface Creation Kit”. It’s highly configurable but comes with sensible defaults out of the box.\n>\n> It aims to make the process of writing command line tools quick and fun while also preventing any frustration caused by the inability to implement an intended CLI API.\n>\n> Click in three points:\n>\n> - Arbitrary nesting of commands\n> - Automatic help page generation\n> - Supports lazy loading of subcommands at runtime\n\n## 使用\n\n```python\nimport click\n\n@click.command()\n@click.option(\"--count\", default=1, help=\"Number of greetings.\")\n@click.option(\"--name\", prompt=\"Your name\", help=\"The person to greet.\")\ndef hello(count, name):\n    \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\"\n    for _ in range(count):\n        click.echo(f\"Hello, {name}!\")\n\nif __name__ == '__main__':\n    hello()\n```\n\n```shell\n$ python hello.py --count=3\nYour name: Click\nHello, Click!\nHello, Click!\nHello, Click!\n```\n","n":0.085}}},{"i":73,"$":{"0":{"v":"内置类型","n":1},"1":{"v":"\n参考[【使用 Python 实现算法】02 原生类型与内置函数 | 那时难决 (duyixian.cn)](https://www.duyixian.cn/2022/06/27/2022-06-27%20algorithms%20in%20python%2002/#int)\n\n## int\n\n- int.bit_count\n- int.bit_length\n\n## float\n\n- float.as_integer_ration\n- 格式化：`f\"{1/3:.4f}\" == \"0.3333\" `\n\n## list\n\n- 获取并删除指定位置的元素（O(n)复杂度）：list.pop(n)\n\n## tuple\n\n- tuple 对象可以作为字典的键\n\n## dict\n\n- dict.fromkeys\n- 可使用[[字典推导式|programming-languages.python.list comprehension]]初始化 dict：`{ch: count for ch, count in [(\"a\", 1), (\"b\", 2), (\"c\", 3)]} == {\"a\": 1, \"b\": 2, \"c\": 3}`\n- 可使用`|`合并 dict，`{1: 2, 2: 3} | {2: 4, 3: 5} == {1: 2, 2: 4, 3: 5}`\n\n## set\n\n- 可使用[[集合推导式|programming-languages.python.list comprehension]]初始化 set：`{x for x in range(10) if x % 2 == 0} == {0, 2, 4, 6, 8}`\n- set 支持的一些运算符：`&` `|` `-` `>` `>=` `<` `<=`\n\n## str\n\n- 使用各类 str.isxxx 方法检查字符串内容\n- str.partition： `assert \"A B C\".partition(\" \") == (\"A\", \" \", \"B C\") `\n","n":0.097}}},{"i":74,"$":{"0":{"v":"内置函数","n":1},"1":{"v":"\n参考[【使用 Python 实现算法】02 原生类型与内置函数 | 那时难决 (duyixian.cn)](https://www.duyixian.cn/2022/06/27/2022-06-27%20algorithms%20in%20python%2002/#int)\n\n## round\n\nPython 的 round 实现为银行家算法，四舍六入五成双\n\n```python\nassert round(1.2) == 1\nassert round(1.6) == 2\nassert round(1.5) == 2\nassert round(2.5) == 2\n```\n\n## all, any\n\n会提前返回\n\n## next\n\n可以应用在获取第一个符合条件的元素的场景。\n\n```python\nassert next(x for x in range(1, 10) if x % 3 == 0) == 3\n```\n\n## enumerate\n\n```python\nfor index, ch in enumerate(\"abc\"):\n    pass\n```\n\n## map, filter\n\n返回一个[[迭代器 | programming-languages.python.iterators]]，可使用列表推导式替换\n\n## sorted\n\n返回的是一个 list\n\n## zip\n\n可用于初始化 dict\n\n```python\nassert dict(zip('abcd', range(4))) == {'a': 0, 'b': 1, 'c': 2, 'd': 3}\n```\n\n可以使用 zip 进行矩阵转置。\n\n```python\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert [list(row) for row in zip(*matrix)] == [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n```\n","n":0.104}}},{"i":75,"$":{"0":{"v":"Asyncio","n":1},"1":{"v":"## 介绍\n\n[asyncio](https://docs.python.org/zh-cn/3/library/asyncio.html)是 Python 原生的协程标准库。\n\n> asyncio 是用来编写 **并发** 代码的库，使用 **async/await** 语法。\n>\n> asyncio 被用作多个提供高性能 Python 异步框架的基础，包括网络和网站服务，数据库连接库，分布式任务队列等等。\n>\n> asyncio 往往是构建 IO 密集型和高层级 **结构化** 网络代码的最佳选择。\n>\n> asyncio 提供一组 **高层级** API 用于:\n>\n> - 并发地 [**运行 Python 协程**](https://docs.python.org/zh-cn/3/library/asyncio-task.html#coroutine) 并对其执行过程实现完全控制;\n> - 执行 [**网络 IO 和 IPC**](https://docs.python.org/zh-cn/3/library/asyncio-stream.html#asyncio-streams);\n> - 控制 [**子进程**](https://docs.python.org/zh-cn/3/library/asyncio-subprocess.html#asyncio-subprocess);\n> - 通过 [**队列**](https://docs.python.org/zh-cn/3/library/asyncio-queue.html#asyncio-queues) 实现分布式任务;\n> - [**同步**](https://docs.python.org/zh-cn/3/library/asyncio-sync.html#asyncio-sync) 并发代码;\n>\n> 此外，还有一些 **低层级** API 以支持 _库和框架的开发者_ 实现:\n>\n> - 创建和管理 [**事件循环**](https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio-event-loop)，以提供异步 API 用于 [<span class=\"pre\">网络化</span>](https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.create_server \"asyncio.loop.create_server\"), 运行 [<span class=\"pre\">子进程</span>](https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.subprocess_exec \"asyncio.loop.subprocess_exec\")，处理 [<span class=\"pre\">OS</span><span> </span><span class=\"pre\">信号</span>](https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.add_signal_handler \"asyncio.loop.add_signal_handler\") 等等;\n> - 使用 [**transports**](https://docs.python.org/zh-cn/3/library/asyncio-protocol.html#asyncio-transports-protocols) 实现高效率协议;\n> - 通过 async/await 语法 [**桥接**](https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio-futures) 基于回调的库和代码。\n\n## 生态\n\n- ASGI（[[programming-languages.python.FastAPI]]）\n- [timofurrer/awesome-asyncio](https://github.com/timofurrer/awesome-asyncio)\n","n":0.109}}},{"i":76,"$":{"0":{"v":"Zen of Python","n":0.577},"1":{"v":"\n# Python 之禅\n\nPython 之禅是 Tim Peters 对 Python 编程思想的诠释。可以在交互式 Python 终端通过`import this`来获取到其内容。\n\n## 内容\n\n> Beautiful is better than ugly.\n>\n> Explicit is better than implicit.\n>\n> Simple is better than complex.\n>\n> Complex is better than complicated.\n>\n> Flat is better than nested.\n>\n> Sparse is better than dense.\n>\n> Readability counts.\n>\n> Special cases aren't special enough to break the rules.\n>\n> Although practicality beats purity.\n>\n> Errors should never pass silently.\n>\n> Unless explicitly silenced.\n>\n> In the face of ambiguity, refuse the temptation to guess.\n>\n> There should be one-- and preferably only one --obvious way to do it.\n>\n> Although that way may not be obvious at first unless you're Dutch.\n>\n> Now is better than never.\n>\n> Although never is often better than _right_ now.\n>\n> If the implementation is hard to explain, it's a bad idea.\n>\n> If the implementation is easy to explain, it may be a good idea.\n>\n> Namespaces are one honking great idea -- let's do more of those!\n","n":0.082}}},{"i":77,"$":{"0":{"v":"Tensorflow","n":1},"1":{"v":"\n## 介绍\n\n[Tensorflow](https://pypi.org/project/tensorflow/)是一个机器学习框架。\n\n> TensorFlow is an open source software library for high performance numerical computation. Its flexible architecture allows easy deployment of computation across a variety of platforms (CPUs, GPUs, TPUs), and from desktops to clusters of servers to mobile and edge devices.\n>\n> Originally developed by researchers and engineers from the Google Brain team within Google's AI organization, it comes with strong support for machine learning and deep learning and the flexible numerical computation core is used across many other scientific domains.\n","n":0.111}}},{"i":78,"$":{"0":{"v":"Pytorch","n":1},"1":{"v":"\n## 介绍\n\n[PyTorch](https://pypi.org/project/torch/)是一个机器学习框架。\n\n> PyTorch is a Python package that provides two high-level features:\n>\n> - Tensor computation (like NumPy) with strong GPU acceleration\n> - Deep neural networks built on a tape-based autograd system\n","n":0.18}}},{"i":79,"$":{"0":{"v":"PyQT5","n":1},"1":{"v":"\n## 介绍\n\n[PyQT5](https://pypi.org/project/PyQt5/)是 QT5 框架的 Python 绑定。\n\n> Qt is set of cross-platform C++ libraries that implement high-level APIs for accessing many aspects of modern desktop and mobile systems. These include location and positioning services, multimedia, NFC and Bluetooth connectivity, a Chromium based web browser, as well as traditional UI development.\n>\n> PyQt5 is a comprehensive set of Python bindings for Qt v5. It is implemented as more than 35 extension modules and enables Python to be used as an alternative application development language to C++ on all supported platforms including iOS and Android.\n>\n> PyQt5 may also be embedded in C++ based applications to allow users of those applications to configure or enhance the functionality of those applications.\n","n":0.093}}},{"i":80,"$":{"0":{"v":"Flask","n":1},"1":{"v":"\n## 介绍\n\n[Flask](https://pypi.org/project/Flask/)是一个 Python Web 框架。\n\n> Flask is a lightweight [WSGI](https://wsgi.readthedocs.io/) web application framework. It is designed to make getting started quick and easy, with the ability to scale up to complex applications. It began as a simple wrapper around [Werkzeug](https://werkzeug.palletsprojects.com/) and [Jinja](https://jinja.palletsprojects.com/) and has become one of the most popular Python web application frameworks.\n\n## 特点\n\n- 微框架\n- 基于[Werkzeug](https://werkzeug.palletsprojects.com/) WSGI 框架 与 [Jinja](https://jinja.palletsprojects.com/)模板\n- 可以通过第三方扩展增强功能\n\n## 资源\n\n![[resources.books#Flask:#*]]\n","n":0.126}}},{"i":81,"$":{"0":{"v":"FastAPI","n":1},"1":{"v":"\n## 介绍\n\n[FastAPI](https://pypi.org/project/fastapi/)是一个新兴的 Python Web 框架。\n\n> FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.6+ based on standard Python type hints.\n>\n> The key features are:\n>\n> - **Fast** : Very high performance, on par with **NodeJS** and **Go** (thanks to Starlette and Pydantic). [One of the fastest Python frameworks available](https://pypi.org/project/fastapi/#performance).\n> - **Fast to code** : Increase the speed to develop features by about 200% to 300%. \\*\n> - **Fewer bugs** : Reduce about 40% of human (developer) induced errors. \\*\n> - **Intuitive** : Great editor support. Completion everywhere. Less time debugging.\n> - **Easy** : Designed to be easy to use and learn. Less time reading docs.\n> - **Short** : Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs.\n> - **Robust** : Get production-ready code. With automatic interactive documentation.\n> - **Standards-based** : Based on (and fully compatible with) the open standards for APIs: [OpenAPI](https://github.com/OAI/OpenAPI-Specification) (previously known as Swagger) and [JSON Schema](https://json-schema.org/).\n","n":0.08}}},{"i":82,"$":{"0":{"v":"Django","n":1},"1":{"v":"\n## 介绍\n\n[Django](https://pypi.org/project/Django/)是一个 Python Web 开发框架。\n\n## 特点\n\n- 大而全\n- 自带 ORM 与模板渲染\n- 适用于关系型数据库\n\n## 资源\n\n![[resources.books#Django:#*]]\n","n":0.289}}},{"i":83,"$":{"0":{"v":"Ansible","n":1},"1":{"v":"\n## 介绍\n\n[ansible](https://pypi.org/project/ansible/)是一个基于 Python 的自动化运维工具\n\n> Ansible is a radically simple IT automation system. It handles configuration management, application deployment, cloud provisioning, ad-hoc task execution, network automation, and multi-node orchestration. Ansible makes complex changes like zero-downtime rolling updates with load balancers easy. More information on the Ansible [website](https://ansible.com/).\n\n## 资源\n\n![[resources.books#ansible:#*]]\n","n":0.146}}},{"i":84,"$":{"0":{"v":"元编程","n":1}}},{"i":85,"$":{"0":{"v":"JavaScript","n":1}}},{"i":86,"$":{"0":{"v":"Java","n":1}}},{"i":87,"$":{"0":{"v":"Golang","n":1}}},{"i":88,"$":{"0":{"v":"函数式编程","n":1}}},{"i":89,"$":{"0":{"v":"编程语言分类","n":1}}},{"i":90,"$":{"0":{"v":"C","n":1}}},{"i":91,"$":{"0":{"v":"C++","n":1}}},{"i":92,"$":{"0":{"v":"C#","n":1}}},{"i":93,"$":{"0":{"v":"结构化编程","n":1}}},{"i":94,"$":{"0":{"v":"面向对象编程","n":1}}},{"i":95,"$":{"0":{"v":"开源","n":1}}},{"i":96,"$":{"0":{"v":"开源协议","n":1}}},{"i":97,"$":{"0":{"v":"数据库","n":1}}},{"i":98,"$":{"0":{"v":"Time Series Databases","n":0.577}}},{"i":99,"$":{"0":{"v":"Relational Database","n":0.707}}},{"i":100,"$":{"0":{"v":"SQLLite","n":1}}},{"i":101,"$":{"0":{"v":"MySQL","n":1}}},{"i":102,"$":{"0":{"v":"ORMs","n":1}}},{"i":103,"$":{"0":{"v":"NoSQL","n":1}}},{"i":104,"$":{"0":{"v":"MongoDB","n":1}}},{"i":105,"$":{"0":{"v":"Indexes","n":1}}},{"i":106,"$":{"0":{"v":"Graph Databases","n":0.707}}},{"i":107,"$":{"0":{"v":"CAP","n":1}}},{"i":108,"$":{"0":{"v":"ACID","n":1}}},{"i":109,"$":{"0":{"v":"基础知识","n":1},"1":{"v":"\n## 参考\n\n![[resources.books#基础]]\n","n":0.707}}},{"i":110,"$":{"0":{"v":"软件","n":1}}},{"i":111,"$":{"0":{"v":"操作系统","n":1},"1":{"v":"## 核心\n\n- 资源虚拟化\n- 并发\n- 持久性\n\n## 设计目标\n\n- 建立抽象\n- 高性能\n- 提供保护\n\n\n## 资源\n\n![[resources.books#操作系统:#*]]\n","n":0.316}}},{"i":112,"$":{"0":{"v":"Threads And Concurrency","n":0.577}}},{"i":113,"$":{"0":{"v":"Process Management","n":0.707},"1":{"v":"\n## 概念\n\n操作系统为正在运行的程序提供的抽象。\n\n### 机器状态\n\n进程需要知晓程序的机器状态\n\n- 内存（代码和数据）\n- 寄存器\n\n### 进程状态\n\n![进程状态](https://res.weread.qq.com/wrepub/epub_30179184_6)\n\n### Unix 进程 API\n\n- fork 调用\n- wait 调用\n- exec 调用\n\n### 用户模式与内核模式\n\n> 硬件通过提供不同的执行模式来协助操作系统。在用户模式（user mode）下，应用程序不能完全访问硬件资源。在内核模式（kernel mode）下，操作系统可以访问机器的全部资源。还提供了陷入（trap）内核和从陷阱返回（return-from-trap）到用户模式程序的特别说明，以及一些指令，让操作系统告诉硬件陷阱表（trap table）在内存中的位置。\n\n### 时钟中断\n\n> 时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统重新获得 CPU 的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。\n\n## 进程调度\n\n### 周转时间\n\n- 先进先出（FIFO）\n- 最短任务优先（SJF）\n- 最短完成时间优先（STCF）\n\n### 响应时间\n\n- 轮转\n\n### 多级反馈队列（Multi-level Feedback Queue，MLFQ）\n\n- 规则1：如果A的优先级 > B的优先级，运行A（不运行B）。\n- 规则2：如果A的优先级 = B的优先级，轮转运行A和B。\n- 规则3：工作进入系统时，放在最高优先级（最上层队列）。\n- 规则4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。\n- 规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列。（应对饥饿问题）\n\n> MLFQ有趣的原因是：它不需要对工作的运行方式有先验知识，而是通过观察工作的运行来给出对应的优先级。通过这种方式，MLFQ可以同时满足各种工作的需求：对于短时间运行的交互型工作，获得类似于SJF/STCF的很好的全局性能，同时对长时间运行的CPU密集型负载也可以公平地、不断地稳步向前。因此，许多系统使用某种类型的MLFQ作为自己的基础调度程序，包括类BSD UNIX系统[LM+89，B86]、Solaris[M06]以及Windows NT和其后的Window系列操作系统。\n\n### 多处理器进程调度\n\n- 单队列\n- 多队列\n- 进程迁移","n":0.14}}},{"i":114,"$":{"0":{"v":"POSIX Basics","n":0.707}}},{"i":115,"$":{"0":{"v":"Memory Management","n":0.707},"1":{"v":"\n## 虚拟内存\n\n### 目标\n\n- 透明\n- 效率\n- 保护\n\n## 类型\n\n### 栈内存\n\n### 堆内存\n\n- malloc 调用\n- free 调用\n\n### 错误\n\n- segment fault 忘记分配内存\n- buffer overflow 缓冲区溢出 安全风险\n- uninitialized read\n- memory leak 内存泄漏\n- dangling pointer 悬垂指针\n- double free 重复释放\n- invalid free 无效释放\n\n## 内存管理\n\n### 地址转换\n\n#### dynamic relocation 动态重定位\n\n```\nphysical address = virtual address + base\n```\n\n![os-memory-management](https://res.weread.qq.com/wrepub/epub_30179184_52)\n\n### 分段\n\n### 空闲空间管理\n\n- 最优匹配\n- 最差匹配\n- 首次匹配\n- 下次匹配\n\n[Linux 内存管理中的 slab 分配器 ](https://www.cnblogs.com/pengdonglin137/p/3878552.html)\n\n### 分页\n\n![分页](https://res.weread.qq.com/wrepub/epub_30179184_85)\n\n> #### 数据结构——页表\n>\n> 现代操作系统的内存管理子系统中最重要的数据结构之一就是页表（page table）。通常，页表存储虚拟—物理地址转换（virtual-to-physical address translation），从而让系统知道地址空间的每个页实际驻留在物理内存中的哪个位置。由于每个地址空间都需要这种转换，因此一般来说，系统中每个进程都有一个页表。页表的确切结构要么由硬件（旧系统）确定，要么由 OS（现代系统）更灵活地管理。\n\n#### 交换空间","n":0.124}}},{"i":116,"$":{"0":{"v":"Interprocess Communication","n":0.707}}},{"i":117,"$":{"0":{"v":"IO Management","n":0.707},"1":{"v":"\n![系统架构](https://res.weread.qq.com/wrepub/epub_30179184_142)\n\n## DMA(Direct Memory Access)\n\n## 设备驱动程序\n\n大部分操作系统内核代码都是驱动程序。\n\n## 磁盘驱动器\n\n平均寻道时间\n\n### 磁盘调度\n\n- 最短寻道时间优先\n- 电梯算法（C-SCAN）\n\n## 廉价冗余磁盘阵列（RAID）\n\n- RAID 0(条带化)\n- RAID 1(镜像)\n- RAID 4(奇偶校验)\n- RAID 5(旋转奇偶校验)\n\n![RAID](https://res.weread.qq.com/wrepub/epub_30179184_187)\n\n## 文件系统\n\n- 文件\n- 目录\n- inode\n- open 调用\n- 文件描述符\n- fsync 调用\n- 硬链接，软链接，unlink\n- 文件系统检查程序（fsck）与日志\n- ext3/ext4，NTFS，btrfs\n\n> inode 是许多文件系统中使用的通用名称，用于描述保存给定文件的元数据的结构，例如其长度、权限以及其组成块的位置。这个名称至少可以追溯到 UNIX（如果不是早期的系统，可能还会追溯到 Multics）。它是 index node（索引节点）的缩写，因为 inode 号用于索引磁盘上的 inode 数组，以便查找该 inode 号对应的 inode。我们将看到，inode 的设计是文件系统设计的一个关键部分。大多数现代系统对于它们记录的每个文件都有这样的结构，但也许用了不同的名字（如 dnodes、fnodes 等）。\n\n### 数据完整性与保护\n\n- 校验和\n","n":0.144}}},{"i":118,"$":{"0":{"v":"Concurrent","n":1},"1":{"v":"\n## 线程\n\n- 独立寄存器\n- 共享地址空间\n- 使用线程控制块 Thread Control Block 维护状态\n- 独立栈空间（Thread Local）\n\n### 线程 API\n\n- 创建\n- 完成（join）\n- 互斥量\n- 条件变量\n\n---\n\n## 线程安全\n\n- 临界区（访问共享资源的代码）\n- 竞态条件（多个线程进入临界区）\n- 互斥执行\n- 原子操作\n\n## 锁\n\nPthread 锁（mutex）\n\n### 特性\n\n- 提供互斥\n- 公平性\n- 性能\n\n### 原子指令\n\n- test-and-set\n- compare-and-set\n- fetch-and-set\n\n### 自旋锁\n\n需要主动让出 CPU 以避免其他线程饿死\n\n> 提示：更多并发不一定更快\n>\n> 如果方案带来了大量的开销（例如，频繁地获取锁、释放锁），那么高并发就没有什么意义。如果简单的方案很少用到高开销的调用，通常会很有效。增加更多的锁和复杂性可能会适得其反。话虽如此，有一种办法可以获得真知：实现两种方案（简单但少一点并发，复杂但多一点并发），测试它们的表现。毕竟，你不能在性能上作弊。结果要么更快，要么不快。\n\n### 信号量\n\n- 二值信号量（锁）\n- 信号量可作为条件变量\n- 生产者/消费者问题（有界缓冲区）\n- 哲学家就餐\n\n## 常见并发问题\n\n### 非死锁缺陷\n\n- 违反原子性缺陷\n- 违反顺序缺陷\n\n### 死锁缺陷\n\n#### 产生死锁的条件\n\n- 互斥\n- 占有并等待\n- 非抢占\n- 循环等待\n\n#### 预防和避免死锁\n\n- 避免循环等待\n- wait-free 数据结构\n- 检查和回复\n\n## 基于事件的并发\n\nnode.js\n\n### 事件循环\n\n- select(poll)\n- 异步 I/O\n- 状态管理\n","n":0.126}}},{"i":119,"$":{"0":{"v":"硬件","n":1},"1":{"v":"\n## 早期计算设备\n\n- 算盘\n- 计算尺\n- 雅各提花织机（可编程）\n- 差分机\n\n## 电子计算机\n\n- ENIAC\n- EDSAC\n\n## 计算机组成\n\n- [[basic.hardware.cpu]]\n- [[basic.hardware.storage]]\n- [[basic.hardware.IO Devices]]\n","n":0.267}}},{"i":120,"$":{"0":{"v":"存储","n":1}}},{"i":121,"$":{"0":{"v":"RAM","n":1}}},{"i":122,"$":{"0":{"v":"Hard Disks And Secondary Storage","n":0.447}}},{"i":123,"$":{"0":{"v":"CPU","n":1}}},{"i":124,"$":{"0":{"v":"逻辑门","n":1}}},{"i":125,"$":{"0":{"v":"集成电路","n":1}}},{"i":126,"$":{"0":{"v":"Instrution Set","n":0.707},"1":{"v":"\n## RISC 与 CISC\n\n> 在 20 世纪 80 年代，计算机体系结构领域曾发生过一场激烈的讨论。一方是 CISC 阵营，即复杂指令集计算（Complex Instruction Set Computing），另一方是 RISC，即精简指令集计算（Reduced Instruction Set Computing）[PS81]。RISC 阵营以 Berkeley 的 David Patterson 和 Stanford 的 John Hennessy 为代表（他们写了一些非常著名的书[HP06]），尽管后来 John Cocke 凭借他在 RISC 上的早期工作 [CM00]获得了图灵奖。\n>\n> CISC 指令集倾向于拥有许多指令，每条指令比较强大。例如，你可能看到一个字符串拷贝，它接受两个指针和一个长度，将一些字节从源拷贝到目标。CISC 背后的思想是，指令应该是高级原语，这让汇编语言本身更易于使用，代码更紧凑。\n>\n> RISC 指令集恰恰相反。RISC 背后的关键观点是，指令集实际上是编译器的最终目标，所有编译器实际上需要少量简单的原语，可以用于生成高性能的代码。因此，RISC 倡导者们主张，尽可能从硬件中拿掉不必要的东西（尤其是微代码），让剩下的东西简单、统一、快速。\n>\n> 早期的 RISC 芯片产生了巨大的影响，因为它们明显更快[BC91]。人们写了很多论文，一些相关的公司相继成立（例如 MIPS 和 Sun 公司）。但随着时间的推移，像 Intel 这样的 CISC 芯片制造商采纳了许多 RISC 芯片的优点，例如添加了早期流水线阶段，将复杂的指令转换为一些微指令，于是它们可以像 RISC 的方式运行。这些创新，加上每个芯片中晶体管数量的增长，让 CISC 保持了竞争力。争论最后平息了，现在两种类型的处理器都可以跑得很快。\n","n":0.13}}},{"i":127,"$":{"0":{"v":"IO Devices","n":0.707}}},{"i":128,"$":{"0":{"v":"通信","n":1}}},{"i":129,"$":{"0":{"v":"网络","n":1}}},{"i":130,"$":{"0":{"v":"UDP","n":1}}},{"i":131,"$":{"0":{"v":"TCP","n":1}}},{"i":132,"$":{"0":{"v":"HTTP","n":1}}},{"i":133,"$":{"0":{"v":"DNS","n":1}}},{"i":134,"$":{"0":{"v":"压缩","n":1}}},{"i":135,"$":{"0":{"v":"编码","n":1}}},{"i":136,"$":{"0":{"v":"架构","n":1}}},{"i":137,"$":{"0":{"v":"Domain Driven Design","n":0.577}}},{"i":138,"$":{"0":{"v":"Cloud Native","n":0.707}}},{"i":139,"$":{"0":{"v":"PaaS","n":1}}},{"i":140,"$":{"0":{"v":"IaaS","n":1}}},{"i":141,"$":{"0":{"v":"FaaS","n":1}}},{"i":142,"$":{"0":{"v":"关于我","n":1},"1":{"v":"\n## 简介\n\n我是[杜逸先](https://github.com/duyixian1234)，95 年出生的陕西汉子，17 年毕业于浙江大学软件工程专业，目前作为一个研发工程师生活在杭州。\n\n## 技能\n\n### 基础\n\n- [[basic.software.operating-system]]\n- [[basic.communication.network]]\n- [[basic.hardware]]\n\n### 编程语言\n\n| 编程语言                             | 熟练度 | 认可度 | 使用频率 |\n| ------------------------------------ | :----: | ------ | :------- |\n| [[programming-languages.python]]     | ★★★★★  | ★★★★★  | 日常工作 |\n| [[programming-languages.javascript]] |  ★★★   | ★★     | 日常工作 |\n| [[programming-languages.typescript]] |  ★★★   | ★★★★★  | 日常工作 |\n| [[programming-languages.java]]       |  ★★★   | ★★★★   | 偶尔     |\n| [[programming-languages.c]]          |  ★★★   | ★★★★   | 偶尔     |\n| [[programming-languages.c++]]        |  ★★★   | ★★★★   | 偶尔     |\n| [[programming-languages.rust]]       |   ★★   | ★★★★★  | 兴趣学习 |\n| [[programming-languages.golang]]     |   ★    | ★★★    | 兴趣学习 |\n\n### 框架\n\n#### 后端框架\n\n| 框架                                                  | 熟练度 | 认可度 | 使用频率 |\n| ----------------------------------------------------- | ------ | ------ | -------- |\n| [Flask](https://flask.palletsprojects.com/en/2.2.x/)  | ★★★★★  | ★★★★★  | 日常工作 |\n| [FastAPI](https://fastapi.tiangolo.com)               | ★★★★   | ★★★★★  | 日常工作 |\n| [Spring Boot](https://spring.io/projects/spring-boot) | ★★★    | ★★★★★  | 偶尔     |\n\n#### 前端框架\n\n| 框架                             | 熟练度 | 认可度 | 使用频率 |\n| -------------------------------- | ------ | ------ | -------- |\n| [React.js](https://reactjs.org/) | ★★★    | ★★★★★  | 日常工作 |\n| [Angular](https://angular.io/)   | ★★★    | ★★★★   | 兴趣学习 |\n\n### 软件开发\n\n- [[software-develop.design.TDD]]\n- [[software-develop.refactoring]]\n- [[programming-languages.functional programming]]\n\n### DevOps\n\n- [[software-develop.CI]] [[software-develop.CD]]\n- [[software-develop.VCS.git]]\n- [Docker](https://www.docker.com/)\n- [Docker Compose](https://docs.docker.com/compose/)\n- [Kubernetes](https://kubernetes.io/)\n\n#### 平台与工具\n\n- [GitHub](https://github.com/)\n- [Visual Studio Code](https://code.visualstudio.com/)\n\n## 项目经历\n","n":0.074}}}]}
