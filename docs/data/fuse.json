{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"个人知识库","n":1},"1":{"v":"\n\r\n记录我在工作和学习中掌握到的软件开发主题的知识。\r\n\r\n## 已完成\r\n\r\n![[个人介绍 | about me#简介:#*]]\r\n![[programming-languages.python#介绍:#*]]\r\n\r\n- [[basic.software.operating-system]]\r\n- [[security]]\r\n- [[software-develop.design]]\r\n- [[software-develop.design.Design Patterns]]\r\n\r\n## 施工中\r\n\r\n- [[software-develop.VCS.git]]","n":0.289}}},{"i":2,"$":{"0":{"v":"软件开发","n":1}}},{"i":3,"$":{"0":{"v":"Config","n":1}}},{"i":4,"$":{"0":{"v":"Toml","n":1}}},{"i":5,"$":{"0":{"v":"VCS","n":1},"1":{"v":"\n\r\n## 版本控制\r\n\r\n版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。\r\n\r\n## 分类\r\n\r\n### 本地版本控制系统\r\n\r\n![本地版本控制](https://git-scm.com/book/en/v2/images/local.png)\r\n\r\n\r\n### 集中化版本控制系统\r\n\r\n![集中化版本控制](https://git-scm.com/book/en/v2/images/centralized.png)\r\n\r\n- CVS\r\n- Subversion\r\n\r\n### 分布式版本控制系统\r\n\r\n![分布式版本控制](https://git-scm.com/book/en/v2/images/distributed.png)\r\n\r\n- [[software-develop.VCS.git]]\r\n- Mercurial","n":0.316}}},{"i":6,"$":{"0":{"v":"git","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\nGit 是一个分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。\r\n\r\n### 历史\r\n\r\n> 同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。\r\n>\r\n> Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002 年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。\r\n>\r\n> 到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：\r\n>\r\n> - 速度\r\n> - 简单的设计\r\n> - 对非线性开发模式的强力支持（允许成千上万个并行开发的分支）\r\n> - 完全分布式\r\n> - 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）\r\n>\r\n> 自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统\r\n\r\n## Git 是什么\r\n\r\n- 直接记录快照，而非差异比较\r\n- 近乎所有操作都是本地执行\r\n- Git 保证完整性\r\n- Git 一般只添加数据\r\n\r\n### 状态\r\n\r\n- **已修改**表示修改了文件，但还没保存到数据库中。\r\n- **已暂存**表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。\r\n- **已提交**表示数据已经安全地保存在本地数据库中。\r\n\r\n### 工作区、暂存区以及 Git 目录\r\n\r\n![git](https://git-scm.com/book/en/v2/images/areas.png)\r\n\r\n工作区是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。\r\n\r\n暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。\r\n\r\nGit 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。\r\n\r\n### 基本的 Git 工作流程\r\n\r\n1. 在工作区中修改文件。\r\n2. 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。\r\n3. 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。\r\n\r\n## Git 基础\r\n\r\n### 配置\r\n\r\n#### 配置位置\r\n\r\n1. `/etc/gitconfig` 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行`git config` 时带上`--system` 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）\r\n2. `~/.gitconfig` 或`~/.config/git/config` 文件：只针对当前用户。 你可以传递`--global` 选项让 Git 读写此文件，这会对你系统上**所有** 的仓库生效。\r\n3. 当前使用仓库的 Git 目录中的`config` 文件（即`.git/config`）：针对该仓库。 你可以传递`--local` 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）\r\n\r\n每一个级别会覆盖上一级别的配置，所以 `.git/config` 的配置变量会覆盖 `/etc/gitconfig` 中的配置变量。\r\n\r\n#### 配置项\r\n\r\n- `user.name`：设置提交时使用的名字。\r\n- `user.email`：设置提交时使用的邮箱地址。\r\n- `core.editor`：设置 Git 在需要你输入信息时所使用的文本编辑器。\r\n\r\n#### 检查配置信息\r\n\r\n```bash\r\n$ git config --list\r\nuser.name=John Doe\r\nuser.email=johndoe@example.com\r\ncolor.status=auto\r\ncolor.branch=auto\r\ncolor.interactive=auto\r\ncolor.diff=auto\r\n...\r\n```\r\n\r\n## 使用 Git\r\n\r\n### 获取 Git 仓库\r\n\r\n#### 初始化仓库\r\n\r\n```bash\r\n$ git init\r\n```\r\n\r\n#### 克隆现有仓库\r\n\r\n```bash\r\n$ git clone <repo-url> [directory]\r\n```\r\n\r\n### 记录更新到仓库\r\n\r\n![lifecycle](https://git-scm.com/book/en/v2/images/lifecycle.png)\r\n\r\n#### 检查当前文件状态\r\n\r\n```bash\r\n$ git status\r\n```\r\n\r\n#### 跟踪新文件\r\n\r\n```bash\r\n$ git add <filename>\r\n```\r\n\r\n#### 暂存已修改的文件\r\n\r\n```bash\r\n$ git add <filename>\r\n```\r\n\r\n#### 状态简览\r\n\r\n```bash\r\n$ git status -s\r\n```\r\n\r\n#### 忽略文件\r\n\r\n修改 `.gitignore`文件\r\n\r\n##### 生成 .gitignore\r\n\r\n- [github/gitignore: A collection of useful .gitignore templates](https://github.com/github/gitignore)\r\n- [gitignore.io - 为你的项目创建必要的 .gitignore 文件 (toptal.com)](https://www.toptal.com/developers/gitignore)\r\n- [.gitignore Generator - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=piotrpalarz.vscode-gitignore-generator)\r\n\r\n#### 查看已暂存和未暂存的文件\r\n\r\n```bash\r\n$ git diff [--staged]\r\n```\r\n\r\n#### 提交更新\r\n\r\n```bash\r\n$ git commit\r\n```\r\n\r\n#### 跳过使用暂存区域\r\n\r\n```bash\r\n$ git commit -a -m \"Commit Message\"\r\n```\r\n\r\n#### 移除文件\r\n\r\n```bash\r\n$ git rm <filename>\r\n```\r\n\r\n##### 仅移除暂存区文件\r\n\r\n```bash\r\n$ git rm --cached <filename>\r\n```\r\n\r\n#### 移动文件\r\n\r\n```bash\r\ngit mv file_from file_to\r\n```\r\n\r\n### 查看提交历史\r\n\r\n```bash\r\ngit log\r\n```\r\n\r\n#### 格式\r\n\r\n```bash\r\n$ git log --pretty=oneline\r\n```\r\n\r\n| 选项 | 说明                                          |\r\n| ---- | --------------------------------------------- |\r\n| %H   | 提交的完整哈希值                              |\r\n| %h   | 提交的简写哈希值                              |\r\n| %T   | 树的完整哈希值                                |\r\n| %t   | 树的简写哈希值                                |\r\n| %P   | 父提交的完整哈希值                            |\r\n| %p   | 父提交的简写哈希值                            |\r\n| %an  | 作者名字                                      |\r\n| %ae  | 作者的电子邮件地址                            |\r\n| %ad  | 作者修订日期（可以用 --date=选项 来定制格式） |\r\n| %ar  | 作者修订日期，按多久以前的方式显示            |\r\n| %cn  | 提交者的名字                                  |\r\n| %ce  | 提交者的电子邮件地址                          |\r\n| %cd  | 提交日期                                      |\r\n| %cr  | 提交日期（距今多长时间）                      |\r\n| %s   | 提交说明                                      |\r\n\r\n#### 常用选项\r\n\r\n| 选项            | 说明                                                                                                        |\r\n| --------------- | ----------------------------------------------------------------------------------------------------------- |\r\n| -p              | 按补丁格式显示每个提交引入的差异。                                                                          |\r\n| --stat          | 显示每次提交的文件修改统计信息。                                                                            |\r\n| --shortstat     | 只显示 --stat 中最后的行数修改添加移除统计。                                                                |\r\n| --name-only     | 仅在提交信息后显示已修改的文件清单。                                                                        |\r\n| --name-status   | 显示新增、修改、删除的文件清单。                                                                            |\r\n| --abbrev-commit | 仅显示 SHA-1 校验和所有 40 个字符中的前几个字符。                                                           |\r\n| --relative-date | 使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）。                                             |\r\n| --graph         | 在日志旁以 ASCII 图形显示分支与合并历史。                                                                   |\r\n| --pretty        | 使用其他格式显示历史提交信息。可用的选项包括 oneline、short、full、fuller 和 format（用来定义自己的格式）。 |\r\n| --oneline       | --pretty=oneline --abbrev-commit 合用的简写。                                                               |\r\n\r\n### 撤销操作\r\n\r\n#### 重新提交\r\n\r\n```bash\r\n$ git commit --amend\r\n```\r\n\r\n#### 取消暂存的文件\r\n\r\n```bash\r\n$ git reset HEAD <filename>\r\n```\r\n\r\n#### 撤销对文件的修改\r\n\r\n```bash\r\n$ git checkout -- <filename>\r\n```\r\n\r\n### 远程仓库的使用\r\n\r\n#### 查看远程仓库\r\n\r\n```bash\r\n$ git remote -v\r\n```\r\n\r\n#### 添加远程仓库\r\n\r\n```bash\r\n$ git remote add <remote-name> <remote-url>\r\n```\r\n\r\n#### 从远程仓库中抓取与拉取\r\n\r\n```bash\r\n$ git fetch <remote>\r\n```\r\n\r\n#### 推送到远程仓库\r\n\r\n```bash\r\n$ git push <remote> <branch>\r\n```\r\n\r\n#### 远程仓库的重命名与移除\r\n\r\n```bash\r\n$ git remote rename <old-name> <new-name>\r\n$ git remote remove <remote>\r\n```\r\n\r\n### 标签\r\n\r\n#### 列出标签\r\n\r\n```bash\r\n$ git tag\r\n```\r\n\r\n#### 创建标签\r\n\r\n```bash\r\n$ git tag -a <tag> -m <message>\r\n$ git tag <tag>\r\n```\r\n\r\n#### 后期打标签\r\n\r\n```bash\r\n$ git tag <tag> <commit-id>\r\n```\r\n\r\n#### 共享标签\r\n\r\n```bash\r\n$ git push <remote> <tag>\r\n```\r\n\r\n#### 删除标签\r\n\r\n```bash\r\n$ git tag -d <tag> # local\r\n$ git push origin --delete <tag> # remote\r\n```\r\n\r\n#### 检出标签\r\n\r\n```bash\r\n$ git checkout <tag>\r\n$ git checkout -b <new-branch> <tag>\r\n```\r\n\r\n### Git 别名\r\n\r\n```bash\r\n$ git config --global alias.co checkout\r\n$ git config --global alias.br branch\r\n$ git config --global alias.ci commit\r\n$ git config --global alias.st status\r\n```\r\n\r\n或者编辑`.gitconfig`文件的 alias 部分。\r\n\r\n## 资源\r\n\r\n![[resources.links#git:#*]]\r\n","n":0.046}}},{"i":7,"$":{"0":{"v":"Tools","n":1}}},{"i":8,"$":{"0":{"v":"Editor","n":1}}},{"i":9,"$":{"0":{"v":"Visual Studio Code","n":0.577}}},{"i":10,"$":{"0":{"v":"Testing","n":1}}},{"i":11,"$":{"0":{"v":"Unit Testing","n":0.707}}},{"i":12,"$":{"0":{"v":"重构","n":1}}},{"i":13,"$":{"0":{"v":"Mobile Application","n":0.707}}},{"i":14,"$":{"0":{"v":"前端","n":1}}},{"i":15,"$":{"0":{"v":"Dev Ops","n":0.707}}},{"i":16,"$":{"0":{"v":"Desktop Application","n":0.707}}},{"i":17,"$":{"0":{"v":"软件设计","n":1},"1":{"v":"\n\r\n## 设计理念\r\n\r\n- [[software-develop.design.SOLID]]\r\n- [[software-develop.design.DRY]]\r\n- [[software-develop.design.YAGNI]]\r\n- [[software-develop.design.KISS]]\r\n\r\n## 设计模式\r\n\r\n[[software-develop.design.Design Patterns]]","n":0.354}}},{"i":18,"$":{"0":{"v":"YAGNI","n":1},"1":{"v":"\n\r\n## You aren’t gonna need it\r\n\r\n> Developers should start building capabilities only when those capabilities are actually needed, rather than trying to predict future needs. \r\n","n":0.196}}},{"i":19,"$":{"0":{"v":"TDD","n":1}}},{"i":20,"$":{"0":{"v":"SOLID","n":1},"1":{"v":"\n\r\n## 单一职责原则（Single Responsibility Principle）\r\n\r\n- 每个模块应该只做一件事\r\n- 每个模块都因该有且仅有一个被修改的原因\r\n- 任何一个软件模块都应该只对某一类行为者负责\r\n\r\n## 开放封闭原则（Open Close Principle）\r\n\r\n- 设计良好的计算机软件应该易于扩展，同时抗拒修改\r\n- 如果 A 组件不想被 B 组件上发生的修改所影响，那么就应该让 B 组件依赖于 A 组件\r\n\r\n## 里氏替换原则（Liskov Substitution Principle）\r\n\r\n- 典型反例，Square 与 Rectangle（Rectangle可以分别设置宽和高，Square的变长会被最后一次的设置覆盖）\r\n\r\n\r\n## 接口隔离原则（Interface Sgregation Principle）\r\n\r\n- 模块不应该依赖未使用到的组件\r\n\r\n## 依赖反转原则（Dependency inversion principle）\r\n\r\n- 应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类\r\n- 不要在具体实现类上创建衍生类\r\n- 不要覆盖包含具体实现的函数\r\n- 应避免在代码中写入与任何具体实现相关的名字，或者是其他容易变动的事物的名字\r\n- 常见实践：工厂模式\r\n","n":0.162}}},{"i":21,"$":{"0":{"v":"KISS","n":1},"1":{"v":"\n\r\n## Keep it simple, stupid (KISS)\r\n\r\n> Keep it simple, stupid (KISS) is a design principle which states that designs and/or systems should be as simple as possible. Wherever possible, complexity should be avoided in a system—as simplicity guarantees the greatest levels of user acceptance and interaction. KISS is used in a variety of disciplines, such as interface design, product design, and software development.","n":0.126}}},{"i":22,"$":{"0":{"v":"DRY","n":1},"1":{"v":"\n## Don’t Repeat Yourself\r\n\r\n> The DRY principle stands for “Don’t Repeat Yourself” and was first introduced to the masses by Andy Hunt and Dave Thomas in the book The Pragmatic Programmer, their definition of the DRY principle is as follows:\r\n>\r\n> “Every piece of knowledge must have a single, unambiguous, authoritative representation within a system. The alternative is to have the same thing expressed in two or more places. If you change one, you have to remember to change the others”\r\n\r\n## 参考\r\n\r\n- [DRY 原则](https://www.jianshu.com/p/ecca64cda042)\r\n- [The DRY Principle: Benefits and Costs with Examples (thevaluable.dev)](https://thevaluable.dev/dry-principle-cost-benefit-example/)\r\n","n":0.104}}},{"i":23,"$":{"0":{"v":"设计模式","n":1},"1":{"v":"\n\r\n## 设计模式\r\n\r\n> 设计模式是软件设计中常见问题的典型解决方案。每个模式就像一张蓝图，你可以通过对其进行定制来解决代码中的特定设计问题。\r\n\r\n### 设计模式与库\r\n\r\n> 设计模式与方法或库的使用方式不同， 你很难直接在自己的程序中套用某个设计模式。 模式并不是一段特定的代码， 而是解决特定问题的一般性概念。 你可以根据模式来实现符合自己程序实际所需的解决方案。\r\n\r\n### 设计模式与算法\r\n\r\n> 人们常常会混淆模式和算法， 因为两者在概念上都是已知特定问题的典型解决方案。 但算法总是明确定义达成特定目标所需的一系列步骤， 而模式则是对解决方案的更高层次描述。 同一模式在两个不同程序中的实现代码可能会不一样。\r\n>\r\n> 算法更像是菜谱： 提供达成目标的明确步骤。 而模式更像是蓝图： 你可以看到最终的结果和模式的功能， 但需要自己确定实现步骤。\r\n\r\n### 设计模式的优势\r\n\r\n> - 设计模式是针对软件设计中常见问题的工具箱, 其中的工具就是各种**经过实践验证的解决方案**。 即使你从未遇到过这些问题, 了解模式仍然非常有用, 因为它能指导你如何使用面向对象的设计原则来解决各种问题。\r\n> - 设计模式定义了一种让你和团队成员能够更高效沟通的通用语言。 你只需说“**哦, 这里用单例就可以了**”, 所有人都会理解这条建议背后的想法。 只要知晓模式及其名称, 你就无需解释什么是单例。\r\n\r\n### 关于设计模式的争议\r\n\r\n#### 一种针对不完善编程语言的蹩脚解决方案\r\n\r\n> 通常当所选编程语言或技术缺少必要的抽象功能时，人们才需要设计模式。在这种情况下，模式是一种可为语言提供更优功能的蹩脚解决方案。\r\n>\r\n> 例如，策略模式在绝大部分现代编程语言中可以简单地使用匿名（lamb­da）函数来实现。\r\n\r\n#### 低效的解决方案\r\n\r\n> 模式试图将已经广泛使用的方式系统化。许多人会将这样的统一化认为是某种教条，他们会 “全心全意” 地实施这样的模式， 而不会根据项目的实际情况对其进行调整。\r\n\r\n#### 不当使用\r\n\r\n> 如果你只有一把铁锤， 那么任何东西看上去都像是钉子。\r\n>\r\n> 这个问题常常会给初学模式的人们带来困扰：在学习了某个模式后，他们会在所有地方使用该模式，即便是在较为简单的代码也能胜任的地方也是如此。\r\n\r\n## 分类\r\n\r\n### 创建型模式\r\n\r\n[[software-develop.design.Design Patterns.creational patterns]]提供创建对象的机制， 增加已有代码的灵活性和可复用性。\r\n\r\n### 结构型模式\r\n\r\n[[software-develop.design.Design Patterns.structrual patterns]]介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。\r\n\r\n### 行为模式\r\n\r\n[[software-develop.design.Design Patterns.behavior patterns]]负责对象间的高效沟通和职责委派。\r\n\r\n## 参考\r\n\r\n![[resources.links#设计模式:#*]]\r\n","n":0.129}}},{"i":24,"$":{"0":{"v":"结构型模式","n":1},"1":{"v":"\n\r\n## 适配器模式\r\n\r\n[适配器模式](https://refactoringguru.cn/design-patterns/adapter)\r\n\r\n**适配器模式**是一种结构型设计模式，它能使接口不兼容的对象能够相互合作。\r\n\r\n## 桥接模式\r\n\r\n[桥接模式](https://refactoringguru.cn/design-patterns/bridge)\r\n\r\n**桥接模式**是一种结构型设计模式，可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。\r\n\r\n## 组合模式\r\n\r\n[组合模式](https://refactoringguru.cn/design-patterns/composite)\r\n\r\n**组合模式**是一种结构型设计模式，你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们。\r\n\r\n## 装饰模式\r\n\r\n[装饰模式](https://refactoringguru.cn/design-patterns/decorator)\r\n\r\n装饰模式是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。\r\n\r\n## 外观模式\r\n\r\n[外观模式](https://refactoringguru.cn/design-patterns/facade)\r\n\r\n**外观模式**是一种结构型设计模式，能为程序库、框架或其他复杂类提供一个简单的接口。\r\n\r\n## 享元模式\r\n\r\n[享元模式](https://refactoringguru.cn/design-patterns/flyweight)\r\n\r\n**享元模式**是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象。\r\n\r\n## 代理模式\r\n\r\n[代理模式](https://refactoringguru.cn/design-patterns/proxy)\r\n\r\n**代理模式**是一种结构型设计模式，让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。\r\n","n":0.354}}},{"i":25,"$":{"0":{"v":"创建型模式","n":1},"1":{"v":"\n\r\n创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性。\r\n\r\n## 工厂方法\r\n\r\n[工厂方法模式](https://refactoringguru.cn/design-patterns/factory-method)\r\n\r\n**工厂方法模式**是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。\r\n\r\n## 抽象工厂\r\n\r\n[抽象工厂模式](https://refactoringguru.cn/design-patterns/abstract-factory)\r\n\r\n**抽象工厂模式**是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类。\r\n\r\n## 生成器（建造者）\r\n\r\n[生成器模式](https://refactoringguru.cn/design-patterns/builder)\r\n\r\n**生成器模式**是一种创建型设计模式，使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。\r\n\r\n## 原型\r\n\r\n[原型模式](https://refactoringguru.cn/design-patterns/prototype)\r\n\r\n**原型模式**是一种创建型设计模式，使你能够复制已有对象，而又无需使代码依赖它们所属的类。\r\n\r\n## 单例\r\n\r\n[单例模式](https://refactoringguru.cn/design-patterns/singleton)\r\n\r\n**单例模式**是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。\r\n","n":0.333}}},{"i":26,"$":{"0":{"v":"行为型模式","n":1},"1":{"v":"\n\r\n## 责任链模式\r\n\r\n[责任链模式](https://refactoringguru.cn/design-patterns/chain-of-responsibility)\r\n\r\n**责任链模式**是一种行为设计模式，允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。\r\n\r\n## 命令模式\r\n\r\n[命令模式](https://refactoringguru.cn/design-patterns/command)\r\n\r\n**命令模式**是一种行为设计模式，它可将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。\r\n\r\n## 迭代器模式\r\n\r\n[迭代器模式](https://refactoringguru.cn/design-patterns/iterator)\r\n\r\n**迭代器模式**是一种行为设计模式，让你能在不暴露集合底层表现形式（列表、 栈和树等）的情况下遍历集合中所有的元素。\r\n\r\n## 中介者模式\r\n\r\n[中介者模式](https://refactoringguru.cn/design-patterns/mediator)\r\n\r\n**中介者模式**是一种行为设计模式，能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作。\r\n\r\n## 备忘录模式\r\n\r\n[备忘录模式](https://refactoringguru.cn/design-patterns/memento)\r\n\r\n**备忘录模式**是一种行为设计模式，允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。\r\n\r\n## 观察者模式\r\n\r\n[观察者模式](https://refactoringguru.cn/design-patterns/observer)\r\n\r\n**观察者模式**是一种行为设计模式，许你定义一种订阅机制，可在对象事件发生时通知多个 “观察” 该对象的其他对象。\r\n\r\n## 状态模式\r\n\r\n[状态模式](https://refactoringguru.cn/design-patterns/state)\r\n\r\n**状态模式**是一种行为设计模式，让你能在一个对象的内部状态变化时改变其行为，使其看上去就像改变了自身所属的类一样。\r\n\r\n## 策略模式\r\n\r\n[策略模式](https://refactoringguru.cn/design-patterns/strategy)\r\n\r\n**策略模式**是一种行为设计模式，它能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。\r\n\r\n## 模板方法模式\r\n\r\n[模板方法模式](https://refactoringguru.cn/design-patterns/template-method)\r\n\r\n**模板方法模式**是一种行为设计模式，它在超类中定义了一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤。\r\n\r\n## 访问者模式\r\n\r\n[访问者模式](https://refactoringguru.cn/design-patterns/visitor)\r\n\r\n**访问者模式**是一种行为设计模式，它能将算法与其所作用的对象隔离开来。\r\n","n":0.267}}},{"i":27,"$":{"0":{"v":"Command Line Tools","n":0.577}}},{"i":28,"$":{"0":{"v":"Mordern Unix Tools","n":0.577},"1":{"v":"\n\r\n## bat\r\n\r\n## exa\r\n\r\n## fd-find\r\n\r\n## gitui\r\n\r\n## httpie\r\n\r\n## iredis\r\n\r\n## miniserve\r\n\r\n## procs\r\n\r\n## ripgrep\r\n\r\n## tokei\r\n","n":0.302}}},{"i":29,"$":{"0":{"v":"Core Utils","n":0.707}}},{"i":30,"$":{"0":{"v":"持续集成","n":1}}},{"i":31,"$":{"0":{"v":"持续部署","n":1}}},{"i":32,"$":{"0":{"v":"API","n":1}}},{"i":33,"$":{"0":{"v":"REST","n":1}}},{"i":34,"$":{"0":{"v":"Open API Spec","n":0.577}}},{"i":35,"$":{"0":{"v":"gRPC","n":1}}},{"i":36,"$":{"0":{"v":"GraphQL","n":1}}},{"i":37,"$":{"0":{"v":"Authentication","n":1}}},{"i":38,"$":{"0":{"v":"信息安全","n":1},"1":{"v":"\n\r\n## 定义\r\n\r\n保护信息和信息系统免受未经授权的访问、使用、泄露、破坏、篡改或毁坏\r\n\r\n## 常见的安全风险\r\n\r\n- 未安装安全补丁程序或更新程序\r\n- 使用弱密码\r\n- 从互联网下载和运行未知程序\r\n- 打开来自不明发件人的电子邮件附件\r\n- 使用未加密的无线网络\r\n\r\n## CIA 三要素\r\n\r\n![安全三要素](https://res.weread.qq.com/wrepub/CB_3300018983_016-01.jpg)\r\n\r\n### 机密性（Confidentiality）\r\n\r\n机密性是指保护我们的数据不被未经授权的人查看的能力。\r\n\r\n### 完整性（Integrity）\r\n\r\n完整性是防止他人以未经授权或不受欢迎的方式更改数据的能力。\r\n\r\n### 可用性（Availability）\r\n\r\n可用性是指在需要时访数据的能力。\r\n\r\n## 攻击\r\n\r\n### 攻击类型\r\n\r\n#### 拦截\r\n\r\n> 拦截攻击允许未经授权的用户访问数据、应用程序或环境，这种攻击主要针对机密性的攻击。拦截的形式可能包括未经授权的查看或复制文件、窃听通话或读取他人的电子邮件。\r\n\r\n#### 中断\r\n\r\n> 中断攻击会使你的资产暂时或永久无法使用。这些攻击通常会影响可用性，也会影响完整性。你可以把邮件服务器 DoS 攻击归类为可用性攻击。\r\n\r\n#### 篡改\r\n\r\n> 篡改攻击涉及资产篡改。这类攻击主要是对完整性的攻击，但也可视为对可用性的攻击。如果以未经授权的方式访问文件并更改其中的数据，则会影响文件数据的完整性。但是，如果文件是管理服务行为的配置文件（如作为 Web 服务器的文件），则更改文件的内容可能会影响该服务的可用性。如果你在 Web 服务的文件中更改配置，导致服务处理加密连接的方式发生改变，你甚至可以称之为对机密性的攻击。\r\n\r\n#### 伪造\r\n\r\n> 伪造攻击涉及使用系统生成的数据、流程、通信或其他类似的资料。与后两种攻击类型一样，伪造攻击主要影响完整性，但也可能影响可用性。在数据库中生成虚假信息就是一种伪造攻击。你也可以生成电子邮件，这是传播恶意软件的常用方法。如果你生成足够多的额外进程、网络流量、电子邮件、Web 流量或任何其他消耗资源的东西，就可以使处理这类流量的服务无法由合法用户使用，从而进行可用性攻击。\r\n\r\n### 威胁、漏洞和风险\r\n\r\n> 威胁是指有可能造成损害的东西。威胁往往倾向于在特定环境下发生，特别是在信息安全领域。例如，一种病毒可能对 Windows 操作系统有影响，但不太可能对 Linux 操作系统产生影响。\r\n\r\n> 漏洞是指弱点或脆弱性，威胁可以利用漏洞给你造成伤害。\r\n\r\n> 风险是指坏事发生的可能性。要想使环境中出现风险，需要同时拥有威胁和可利用的漏洞。\r\n\r\n### 风险管理\r\n\r\n- 确定资产\r\n- 识别威胁\r\n- 评估漏洞\r\n- 评估风险\r\n- 缓解风险\r\n\r\n### 事件响应\r\n\r\n- 准备\r\n- 检测和分析\r\n- 遏制、清除和恢复\r\n- 事后活动\r\n\r\n### 纵深防御\r\n\r\n![纵深防御](https://res.weread.qq.com/wrepub/CB_3300018983_028-01.jpg)\r\n\r\n#### 分层防御\r\n\r\n![外部网络](https://res.weread.qq.com/wrepub/CB_3300018983_029-01.jpg)\r\n![内部网络](https://res.weread.qq.com/wrepub/CB_3300018983_030-01.jpg)\r\n![数据](https://res.weread.qq.com/wrepub/CB_3300018983_031-01.jpg)\r\n\r\n## 资源\r\n\r\n![[resources.books#信息安全:#*]]\r\n","n":0.139}}},{"i":39,"$":{"0":{"v":"安全评估","n":1},"1":{"v":"\n\r\n\r\n## 漏洞评估\r\n\r\n### 映射和发现\r\n\r\n- 映射环境\r\n- 发现新主机\r\n\r\n### 扫描\r\n\r\n- 未经身份验证的扫描\r\n- 经过身份验证的扫描\r\n- 代理扫描\r\n- 应用程序扫描\r\n\r\n### 技术挑战\r\n\r\n- 云\r\n- 容器\r\n\r\n## 渗透测试\r\n\r\n### 渗透测试过程\r\n\r\n- 确定范围\r\n- 侦察\r\n- 发现\r\n- 利用和报告\r\n\r\n![渗透测试过程](https://res.weread.qq.com/wrepub/CB_3300018983_201-01.jpg)\r\n\r\n## 渗透测试分类\r\n\r\n- 黑盒\r\n- 白盒\r\n- 灰盒\r\n- 内部和外部\r\n\r\n## 渗透测试对象\r\n\r\n- 网络渗透测试\r\n- 应用程序渗透测试\r\n- 物理渗透测试\r\n- 社会工程学渗透测试\r\n- 硬件测试\r\n\r\n## 漏洞赏金计划\r\n\r\n## 挑战\r\n\r\n- 云\r\n- 寻找熟练的测试人员\r\n\r\n## 余下的问题\r\n\r\n### 现实测试\r\n\r\n- 实施规则\r\n- 确定范围\r\n- 测试环境\r\n\r\n### 攻击检测\r\n\r\n- 测量仪器（入侵检测系统和防火墙、反恶意软件和文件完整性监视（File Integrity Monitoring，FIM）工具）\r\n- 告警\r\n\r\n### 未来的风险\r\n\r\n- 不断变化的攻击面\r\n- 攻击者的进化\r\n- 技术迭代带来的新风险\r\n\r\n### 修复安全漏洞成本高昂","n":0.143}}},{"i":40,"$":{"0":{"v":"OWASP","n":1}}},{"i":41,"$":{"0":{"v":"操作系统安全","n":1},"1":{"v":"\n\r\n## 操作系统强化\r\n\r\n- 删除所有不必要的软件\r\n- 删除所有不必要的服务\r\n- 更改默认账户\r\n- 应用最小权限原则\r\n- 启用日志和审计\r\n\r\n## 防范恶意软件\r\n\r\n- 反恶意软件工具\r\n- 可执行空间保护\r\n- 软件防火墙和主机入侵检测\r\n\r\n## 操作系统安全工具\r\n\r\n- 扫描器（[nmap](https://nmap.org/)）\r\n- 漏洞评估工具[OpenVAS](http://www.openvas.org/)\r\n- 漏洞利用框架","n":0.258}}},{"i":42,"$":{"0":{"v":"网络安全","n":1},"1":{"v":"\n\r\n## 网络防护\r\n\r\n### 设计安全的网络\r\n\r\n- 网络分段\r\n- 阻塞点\r\n- 冗余\r\n\r\n### 使用防火墙\r\n\r\n- 包过滤\r\n- 状态数据包检测\r\n- 深度包检测\r\n- 代理服务器\r\n- 隔离区（Demilitarized Zone，DMZ）\r\n\r\n### 实现网络入侵检测系统\r\n\r\n入侵检测系统（Intrusion Detection System，IDS）\r\n\r\n- 基于签名的入侵检测系统\r\n- 基于异常的入侵检测系统\r\n\r\n## 网络流量防护\r\n\r\n- 使用 VPN\r\n- 保护无线网络上的数据\r\n- 使用安全协议\r\n\r\n## 网络安全工具\r\n\r\n- 无线防护工具\r\n- 扫描器（[nmap](https://nmap.org/)）\r\n- 包嗅探器（[tcpdump](https://www.tcpdump.org/)，[wireshark](https://www.wireshark.org/)）\r\n- 蜜罐工具\r\n- 防火墙工具（[scapy](https://scapy.net/)）\r\n","n":0.186}}},{"i":43,"$":{"0":{"v":"移动、嵌入式和物联网安全","n":1},"1":{"v":"\n\r\n## 移动安全\r\n\r\n### 保护移动设备\r\n\r\n- 移动设备管理\r\n- 部署模型\r\n\r\n### 移动安全问题\r\n\r\n- 基带操作系统\r\n- 越狱\r\n- 恶意应用程序\r\n- 更新\r\n\r\n## 嵌入式安全\r\n\r\n### 嵌入式设备使用场景\r\n\r\n- 工业控制系统\r\n- 医疗器械\r\n- 汽车\r\n\r\n### 嵌入式设备安全问题\r\n\r\n- 升级嵌入式设备\r\n- 物理影响\r\n\r\n## 物联网安全\r\n\r\n### 物联网设备\r\n\r\n- 打印机\r\n- 监控摄像头\r\n- 物理安全设备\r\n\r\n### 物联网安全问题\r\n\r\n- 缺乏透明度\r\n- 网络安全\r\n- 陈旧设备\r\n","n":0.192}}},{"i":44,"$":{"0":{"v":"身份识别与身份验证","n":1},"1":{"v":"\n\r\n## 概念\r\n\r\n> 身份识别是声称某人或某物是什么，而身份验证则确定该声明是否属实。\r\n\r\n## 身份识别\r\n\r\n- 声称自己是谁\r\n- 身份证实\r\n- 伪造身份\r\n\r\n## 身份验证\r\n\r\n- 因子\r\n- 多因子身份验证\r\n- 双向验证（中间人攻击）\r\n\r\n## 常见的身份识别和身份验证方法\r\n\r\n### 密码\r\n\r\n- 强密码\r\n- 密码管理器\r\n\r\n### 生物识别\r\n\r\n#### 生物识别因子特征\r\n\r\n- 普遍性\r\n- 唯一性\r\n- 恒久性\r\n- 易采集性\r\n- 系统性能\r\n- 可接受性\r\n- 防欺骗性\r\n\r\n#### 性能衡量\r\n\r\n- 错误接受率（False Acceptance Rate，FAR）\r\n- 错误拒绝率（False Rejection Rate，FRR）\r\n- 等错误率（Equal Error Rate，EER）\r\n\r\n![FAR-FRR-EER](https://res.weread.qq.com/wrepub/CB_3300018983_042-01.jpg)\r\n\r\n### 硬件令牌\r\n","n":0.169}}},{"i":45,"$":{"0":{"v":"人因安全","n":1},"1":{"v":"\n\r\n> 在信息安全中，我们把人称为安全程序的“薄弱环节”。不管你设置了什么安全措施，都几乎无法控制你的员工，他们可能会点击危险链接、通过不受保护的通道发送敏感信息、泄露密码或在显眼位置发布重要数据等。\r\n>\r\n> 更糟糕的是，攻击者可以利用这些癖好进行社会工程学攻击，操控他人来获取信息或访问设备。这些攻击通常依赖于人们帮助他人的意愿，特别是当面对似乎陷入困境的人、有威胁性的人（如高层经理）或看起来熟悉的人时。\r\n\r\n## 搜索信息实施社会工程学攻击\r\n\r\n- 人力情报\r\n- 开源情报（简历与招聘信息，社交媒体，公共记录，谷歌黑客，文件元数据）\r\n- 其他类型的情报（地理空间情报，测量和签名情报，信号情报，技术情报，金融情报，网络情报）\r\n\r\n### 谷歌黑客\r\n\r\n- site 将结果限制在特定站点（site:nostarch.com）\r\n- filetype 将结果限制为特定的文件类型（filetype:PDF）\r\n- intext 查找包含一个或多个词的页面（intext:security）\r\n- inurl 查找 URL 中包含一个或多个词的页面（inurl:security）\r\n\r\n## 社会工程学攻击类型\r\n\r\n- 托词（伪装值得信任的人）\r\n- 钓鱼攻击\r\n- 尾随\r\n\r\n## 通过安全培训计划来培养安全意识\r\n\r\n### 密码\r\n\r\n- 强密码避免\r\n- 使用相同密码\r\n\r\n### 社会工程学培训\r\n\r\n### 网络使用\r\n\r\n### 恶意软件\r\n\r\n- 他们不认识的人发来的电子邮件附件。\r\n- 包含潜在可执行文件类型并可能包含恶意软件（如 EXE、ZIP 和 PDF）的电子邮件附件。\r\n- 使用http://bit.ly/等短URL的网页链接（如果有疑问，可以使用诸如http://LinkExpander.com/或http://unshorten.me/等工具验证短URL的目的地）。\r\n- 名称与预期名称略有不同的 Web 链接（例如，myco.org 而不是 myco.com）。\r\n- 来自非官方下载网站的智能手机应用程序。\r\n- 盗版软件。\r\n\r\n### 个人设备\r\n\r\n### 清洁桌面策略\r\n\r\n### 熟悉政策和法规知识\r\n","n":0.149}}},{"i":46,"$":{"0":{"v":"密码学","n":1},"1":{"v":"\n\r\n## 历史\r\n\r\n- 凯撒密码（替代密码）\r\n- 加密机\r\n- 恩尼格玛机器\r\n\r\n### 柯克霍夫原则\r\n\r\n> 1. 系统即使不是数学上不可破译的，也必须是实质上不可破译的。\r\n> 2. 系统不能要求保密；即使被敌人窃取，系统也应该保持安全。\r\n> 3. 密钥必须易于交流和记忆，没有书面说明，并且必须易于更改或修改，以便不同的参与者一起使用。\r\n> 4. 系统应该与电报通信兼容。\r\n> 5. 系统必须是便携式的，并且使用时要求不能多于一个使用者。\r\n> 6. 系统必须易于使用，既不需要复杂的思维，也不需要了解一长串规则。\r\n\r\n## 现代密码工具\r\n\r\n- 关键字密码\r\n- 一次性密码本\r\n\r\n### 对称和非对称密码学\r\n\r\n#### 对称密码学\r\n\r\n- 私钥密码学\r\n- 密钥交换\r\n- 分组密码与流密码\r\n\r\n#### 对称密钥加密\r\n\r\n- DES\r\n- 3DES\r\n- AES\r\n\r\n#### 非对称密码学\r\n\r\n公钥与私钥\r\n\r\n##### 非对称密钥算法\r\n\r\n- RSA\r\n- 椭圆曲线密码学（Elliptic Curve Cryptography，ECC）\r\n- Diffie-Hellman\r\n\r\n##### PGP\r\n\r\n### 散列函数\r\n\r\n- MD5\r\n- SHA-1\r\n\r\n### 数字签名\r\n\r\n- 发送者生成消息的散列\r\n- 使用私钥对散列加密\r\n- 将签名与消息一起发送\r\n- 接收方使用公钥解密签名\r\n- 接收方校验两个散列是否相同\r\n\r\n### 数字证书\r\n\r\n- 证书颁发机构（CA）\r\n- 公钥基础设施（Public Key Infrastructure，PKI）\r\n\r\n## 保护数据\r\n\r\n### 保护静态数据\r\n\r\n#### 数据安全\r\n\r\n- 硬盘加密（[BitLocker](https://docs.microsoft.com/zh-cn/windows/security/information-protection/bitlocker/bitlocker-overview)）\r\n\r\n#### 物理安全\r\n\r\n### 保护动态数据\r\n\r\n#### 保护数据\r\n\r\n- SSL/TLS\r\n\r\n#### 保护连接\r\n\r\n- 虚拟专用网（Virtual Private Network，VPN）\r\n\r\n### 保护使用中的数据\r\n\r\n- 端到端加密\r\n","n":0.123}}},{"i":47,"$":{"0":{"v":"合规、法律和法规","n":1},"1":{"v":"\n\r\n> 在信息安全中，外部规则和法规通常会对收集信息、开展调查和监视网络等活动的能力进行限制。为确保遵守规则，可以设置相关要求，包括保护组织、设计新系统和应用程序、决定数据保留时间、加密或标记敏感数据等。\r\n\r\n## 合规\r\n\r\n- 法规合规\r\n- 行业合规\r\n\r\n## 用控制实现合规\r\n\r\n- 物理控制\r\n- 管理控制\r\n- 技术控制\r\n- 关键控制与补偿控制\r\n\r\n## 保持合规\r\n\r\n- 监视\r\n- 审查\r\n- 记录\r\n- 报告\r\n\r\n## 法律与信息安全\r\n\r\n- 《一般数据保护条例》（General Data Protection Regulation，GDPR）\r\n\r\n## 采用合规框架\r\n\r\n- ISO/IEC 27000《信息安全管理系统——概述和词汇》。\r\n- ISO/IEC 27001《信息技术—安全技术—信息安全管理系统—要求》。\r\n- ISO/IEC 27002《信息安全控制实施守则》。\r\n\r\n## 新技术下的合规\r\n\r\n- 云中的合规\r\n- 区块链合规\r\n- 加密货币合规\r\n","n":0.18}}},{"i":48,"$":{"0":{"v":"授权与访问控制","n":1},"1":{"v":"\n\r\n## 概念\r\n\r\n> 授权是指准确确定被验证方可以做什么的过程。访问控制是用于拒绝或允许访问的工具和系统，通常通过访问控制来实现授权。\r\n\r\n## 访问控制\r\n\r\n### 基本任务\r\n\r\n- 允许访问\r\n- 拒绝访问\r\n- 限制访问（沙箱）\r\n- 撤销访问\r\n\r\n## 实施访问控制\r\n\r\n### 访问控制表（Access Control List，ACL）\r\n\r\n- 文件系统访问控制表\r\n- 网络访问控制列表\r\n\r\n### 基于能力（令牌）的访问控制\r\n\r\n## 访问控制模型\r\n\r\n- 自主访问控制（Discretionary Access Control，DAC）\r\n- 强制访问控制（Mandatory Access Control，MAC）\r\n- 基于规则的访问控制（rule-based access control）\r\n- 基于角色的访问控制（Role-Based Access Control，RBAC）\r\n- 基于属性的访问控制（Attribute-Based Access Control，ABAC）（验证码 CAPTCHA）\r\n- 多级访问控制（multilevel access control）模型\r\n\r\n> 最小权限原则\r\n>\r\n> 最小权限原则规定，你应该只给一方执行功能所需的最低访问等级。例如，组织销售部门的人员完成工作，应该无须访问组织人力资源系统中的数据。违反最小权限原则是当今许多安全问题的根源。\r\n\r\n## 物理访问控制\r\n\r\n- 尾随\r\n- 安检\r\n- 围栏\r\n","n":0.154}}},{"i":49,"$":{"0":{"v":"审计和问责","n":1},"1":{"v":"\n\r\n## 问责\r\n\r\n> 为了让人们对自己的行为负责，必须对环境中的所有活动进行追踪溯源。这意味着必须使用身份识别、身份验证和授权过程，以便了解与事件相关联的人员及其执行该事件的权限。\r\n\r\n### 问责的安全效益\r\n\r\n- 不可否认性\r\n- 威慑\r\n- 入侵检测与防御\r\n- 记录的可接受性\r\n\r\n## 审计\r\n\r\n> 审计是对一个组织的记录进行有系统的检查和审查。在几乎任何环境中，从最低等级的技术到最高等级的技术，通常都会通过使用某种审计来确保人们对其行为负责。\r\n\r\n### 审计对象\r\n\r\n- 密码\r\n- 软件许可证\r\n\r\n### 日志记录\r\n\r\n- 记录关键事件\r\n- 定期检查\r\n- 日志分析\r\n\r\n### 监视\r\n\r\n- 异常与告警\r\n\r\n### 审计与评估\r\n\r\n- 漏洞评估\r\n- 渗透测试\r\n","n":0.213}}},{"i":50,"$":{"0":{"v":"应用程序安全","n":1},"1":{"v":"\n\r\n## 软件开发漏洞\r\n\r\n- 缓冲区溢出\r\n- 并发安全\r\n- 输入验证攻击\r\n- 身份验证攻击\r\n- 授权攻击\r\n- 加密攻击\r\n\r\n## web 安全\r\n\r\n- 客户端攻击（XSS，CSRF，SQL 注入）\r\n- 服务端攻击（输入验证，权限错误）\r\n\r\n## 数据库安全\r\n\r\n- 网络协议中未经身份验证的缺陷。\r\n- 网络协议中的身份验证缺陷。\r\n- 身份验证协议缺陷。\r\n- 未经认证即可访问功能。\r\n- 内部 SQL 元素中的任意代码执行。\r\n- 可保护的 SQL 元素中的任意代码执行。\r\n- 通过 SQL 注入提升权限。\r\n- 本地权限提升问题。\r\n\r\n## 应用安全工具\r\n\r\n- 包嗅探器（[tcpdump](https://www.tcpdump.org/)，[wireshark](https://www.wireshark.org/)）\r\n- Web应用程序分析工具（[OWASP Zed Attack Proxy](https://www.zaproxy.org/)）\r\n- 模糊测试工具\r\n","n":0.169}}},{"i":51,"$":{"0":{"v":"资源","n":1}}},{"i":52,"$":{"0":{"v":"Sites","n":1},"1":{"v":"\n## Python\n\n- [Full Stack Python](https://www.fullstackpython.com/)\n- [Python behind the scenes](https://tenthousandmeters.com/tag/python-behind-the-scenes/)\n- [Real Python](https://realpython.com/)\n- [Python Weekly](https://us2.campaign-archive.com/home/?u=e2e180baf855ac797ef407fc7&id=9e26887fc5)\n- [Tag: Python | 那时难决 (duyixian.cn)](https://www.duyixian.cn/tags/Python/)\n","n":0.236}}},{"i":53,"$":{"0":{"v":"Links","n":1},"1":{"v":"\n\r\n## Python\r\n\r\n- [Building Large Scale Systems and Products with Python | Soroco Engineering](https://engineering.soroco.com/building-large-scale-systems-and-products-with-python/)\r\n- [A deep dive into the “official” Docker image for Python (pythonspeed.com)](https://pythonspeed.com/articles/official-python-docker-image/)\r\n\r\n## 设计模式\r\n\r\n- [设计模式](https://refactoringguru.cn/design-patterns)\r\n\r\n## git\r\n\r\n- [Git - Book](https://git-scm.com/book/zh/v2)\r\n","n":0.183}}},{"i":54,"$":{"0":{"v":"Learn","n":1},"1":{"v":"\n## Python\n\n- [面向初学者的 Python - Learn | Microsoft Docs](https://docs.microsoft.com/zh-cn/learn/paths/beginner-python/)\n- [通过 Python 构建真实的应用程序 - Learn | Microsoft Docs](https://docs.microsoft.com/zh-cn/learn/paths/python-language/)\n","n":0.243}}},{"i":55,"$":{"0":{"v":"Books","n":1},"1":{"v":"\n\r\n## 基础\r\n\r\n- [普林斯顿计算机公开课-布莱恩 W. 柯尼汉](https://weread.qq.com/web/bookDetail/6df32da0719710e26dfd7fe)\r\n\r\n## Python\r\n\r\n- [流畅的 Python-卢西亚诺·拉马略](https://weread.qq.com/web/bookDetail/ab832620715c017eab864a6)\r\n\r\n## Ansible\r\n\r\n- [Ansible 权威指南-李松涛 魏巍 甘捷](https://weread.qq.com/web/bookDetail/975321605ce6489759ea594)\r\n\r\n## Flask\r\n\r\n- [Flask Web 开发：基于 Python 的 Web 应用开发实战（第 2 版）-米格尔·格林贝格](https://weread.qq.com/web/bookDetail/6c632420718ff5d76c6bd79)\r\n- [Flask Web 开发实战：入门、进阶与原理解析-李辉](https://weread.qq.com/web/bookDetail/26132b70715ec2fd26119ee)\r\n\r\n## Django\r\n\r\n- [Django：Web Development with Python-Samuel Dauzon Aidas Bendoraitis Arun Ravindran](https://weread.qq.com/web/bookDetail/1e332a70723006f81e377bf)\r\n\r\n## 操作系统\r\n\r\n- [操作系统导论-雷姆兹·H.阿帕希杜塞尔 安德莉亚·C.阿帕希杜塞尔](https://weread.qq.com/web/bookDetail/db8329d071cc7f70db8a479)\r\n\r\n## 信息安全\r\n\r\n- [信息安全精要：从概念到安全性评估-杰森·安德鲁斯](https://weread.qq.com/web/bookDetail/2c232340813ab6deag013132)\r\n","n":0.156}}},{"i":56,"$":{"0":{"v":"编程语言","n":1}}},{"i":57,"$":{"0":{"v":"TypeScript","n":1}}},{"i":58,"$":{"0":{"v":"结构化编程","n":1}}},{"i":59,"$":{"0":{"v":"Rust","n":1}}},{"i":60,"$":{"0":{"v":"Python","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[Python 教程](https://docs.python.org/zh-cn/3/tutorial/index.html)\r\n\r\n> Python 是一门易于学习、功能强大的编程语言。它提供了高效的高级数据结构，还能简单有效地面向对象编程。Python 优雅的语法和动态类型以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的理想语言。\r\n\r\n## 特点\r\n\r\n- 语法简洁，代码可读性强，易于学习\r\n- 功能强大，支持多种编程范式（ [[programming-languages.Structural Programming]]，[[programming-languages.Object Orinted Programming]]，[[programming-languages.functional programming]],[[programming-languages.meta programming]] ）\r\n- 丰富的内置函数和模块\r\n- 易于扩展（[扩展和嵌入 Python 解释器](https://docs.python.org/zh-cn/3/extending/index.html#extending-index)）\r\n- 具有活跃的社区和强大的生态\r\n\r\n## 应用\r\n\r\n- 编写服务端脚本和命令行程序（ [[programming-languages.python.click]]，[[programming-languages.python.typer]] ）\r\n- 运维/DevOps([[programming-languages.python.Ansible]])\r\n- 爬虫（[[programming-languages.python.requests]]，[[programming-languages.python.playwright]]，[[programming-languages.python.scrapy]] ）\r\n- 大数据/机器学习（ [[programming-languages.python.numpy]]，[[programming-languages.python.pandas]]，[[programming-languages.python.Tensorflow]]，[[programming-languages.python.Pytorch]] ）\r\n- 后端服务开发（ [[programming-languages.python.Flask]]，[[programming-languages.python.Django]]，[[programming-languages.python.FastAPI]] ）\r\n- 客户端应用程序开发（[[programming-languages.python.PyQT5]]）\r\n\r\n## Python 之禅\r\n\r\n![[Python之禅 | programming-languages.python.Zen of Python#内容:#*]]\r\n\r\n## 语言特性\r\n\r\n- [[programming-languages.python.builtin types]]\r\n- [[programming-languages.python.builtin functions]]\r\n- [[programming-languages.python.type hints]]\r\n- [[programming-languages.python.modules]]\r\n- [[programming-languages.python.iterators]]\r\n- [[programming-languages.python.generators]]\r\n- [[programming-languages.python.list comprehension]]\r\n- [[programming-languages.python.decorators]]\r\n- [[programming-languages.python.context manager]]\r\n- [[programming-languages.python.structral pattern match]]\r\n\r\n## 第三方库\r\n\r\n- [Pypi](https://pypi.org/)\r\n- [[programming-languages.python.pip]]\r\n- [[programming-languages.python.poetry]]\r\n\r\n## 虚拟环境\r\n\r\n- [[programming-languages.python.venv]]\r\n- [[programming-languages.python.pipenv]]\r\n\r\n## 并发\r\n\r\n- [[programming-languages.python.multithreading]]\r\n- [[programming-languages.python.gevent]]\r\n- [[programming-languages.python.asyncio]]\r\n\r\n## 资源\r\n\r\n![[resources.books#Python:#*]]\r\n![[resources.learn#Python:#*]]\r\n![[resources.sites#Python:#*]]\r\n![[resources.links#Python:#*]]\r\n","n":0.119}}},{"i":61,"$":{"0":{"v":"Zen of Python","n":0.577},"1":{"v":"\n# Python 之禅\n\nPython 之禅是 Tim Peters 对 Python 编程思想的诠释。可以在交互式 Python 终端通过`import this`来获取到其内容。\n\n## 内容\n\n> Beautiful is better than ugly.\n>\n> Explicit is better than implicit.\n>\n> Simple is better than complex.\n>\n> Complex is better than complicated.\n>\n> Flat is better than nested.\n>\n> Sparse is better than dense.\n>\n> Readability counts.\n>\n> Special cases aren't special enough to break the rules.\n>\n> Although practicality beats purity.\n>\n> Errors should never pass silently.\n>\n> Unless explicitly silenced.\n>\n> In the face of ambiguity, refuse the temptation to guess.\n>\n> There should be one-- and preferably only one --obvious way to do it.\n>\n> Although that way may not be obvious at first unless you're Dutch.\n>\n> Now is better than never.\n>\n> Although never is often better than _right_ now.\n>\n> If the implementation is hard to explain, it's a bad idea.\n>\n> If the implementation is easy to explain, it may be a good idea.\n>\n> Namespaces are one honking great idea -- let's do more of those!\n","n":0.082}}},{"i":62,"$":{"0":{"v":"Venv","n":1},"1":{"v":"\n\r\n## 创建虚拟环境\r\n\r\n```shell\r\nubuntu:tmp/ $ python -m venv .venv                                                                           [20:35:41]\r\nubuntu:tmp/ $ ls -l -a                                                                                       [20:35:49]\r\n总用量 12\r\ndrwxrwxr-x  3 ubuntu ubuntu 4096 8月  13 20:35 .\r\ndrwxr-xr-x 43 ubuntu ubuntu 4096 8月  13 20:35 ..\r\ndrwxrwxr-x  5 ubuntu ubuntu 4096 8月  13 20:35 .venv\r\n```\r\n\r\n## 激活虚拟环境\r\n\r\n```shell\r\nubuntu:tmp/ $ source .venv/bin/activate                                                                      [20:37:29]\r\n(.venv) ubuntu:tmp/ $ which python                                                                           [20:38:01]\r\n/home/ubuntu/tmp/.venv/bin/python\r\n(.venv) ubuntu:tmp/ $                                                                                        [20:38:07]\r\n```","n":0.14}}},{"i":63,"$":{"0":{"v":"Typer","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[typer](https://pypi.org/project/typer/)是[[programming-languages.python.click]]的类型提示版本。\r\n\r\n> Typer is a library for building CLI applications that users will **love using** and developers will **love creating** . Based on Python 3.6+ type hints.\r\n>\r\n> The key features are:\r\n>\r\n> - **Intuitive to write** : Great editor support. Completion everywhere. Less time debugging. Designed to be easy to use and learn. Less time reading docs.\r\n> - **Easy to use** : It's easy to use for the final users. Automatic help, and automatic completion for all shells.\r\n> - **Short** : Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs.\r\n> - **Start simple** : The simplest example adds only 2 lines of code to your app: **1 import, 1 function call** .\r\n> - **Grow large** : Grow in complexity as much as you want, create arbitrarily complex trees of commands and groups of subcommands, with options and arguments.\r\n","n":0.085}}},{"i":64,"$":{"0":{"v":"Type Hints","n":0.707},"1":{"v":"\n\r\n## 介绍\r\n\r\n[typing —— 类型注解支持 — Python 3.10.6 文档](https://docs.python.org/zh-cn/3/library/typing.html#module-typing)\r\n\r\n## 应用场景\r\n\r\n- IDE 提示（ [[software-develop.tools.editor.Visual Studio Code]] ）\r\n- 静态分析（ [[programming-languages.python.mypy]] ）\r\n- 运行时获取类型信息（ [[programming-languages.python.modules#dataclasses]] [[programming-languages.python.pydantic]] [[programming-languages.python.FastAPI]] ）\r\n","n":0.209}}},{"i":65,"$":{"0":{"v":"Tensorflow","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[Tensorflow](https://pypi.org/project/tensorflow/)是一个机器学习框架。\r\n\r\n> TensorFlow is an open source software library for high performance numerical computation. Its flexible architecture allows easy deployment of computation across a variety of platforms (CPUs, GPUs, TPUs), and from desktops to clusters of servers to mobile and edge devices.\r\n>\r\n> Originally developed by researchers and engineers from the Google Brain team within Google's AI organization, it comes with strong support for machine learning and deep learning and the flexible numerical computation core is used across many other scientific domains.\r\n","n":0.111}}},{"i":66,"$":{"0":{"v":"结构化模式匹配","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[Python 3.10 中的模式匹配 | 那时难决 (duyixian.cn)](https://www.duyixian.cn/2021/03/19/Structural%20Pattern%20Matching%20In%20Python%203.10/)\r\n\r\n## 示例\r\n\r\n```python\r\n# 快速排序的一个概念性实现\r\ndef quicksort(arr: list[int]) -> list[int]:\r\n    match arr:\r\n        case first,:\r\n            return [first]\r\n        case first, second:\r\n            return [first, second] if first <= second else [second, first]\r\n        case first, *rest:\r\n            return (\r\n                quicksort([num for num in rest if num <= first])\r\n                + [first]\r\n                + quicksort([num for num in rest if num > first])\r\n            )\r\n```\r\n","n":0.13}}},{"i":67,"$":{"0":{"v":"Scrapy","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[Scrapy](https://pypi.org/project/Scrapy/)是一个 Python 爬虫框架。\r\n","n":0.5}}},{"i":68,"$":{"0":{"v":"Requests","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[requests](https://pypi.org/project/requests/)是一个 Python 的 HTTP 请求库，提供了简单、优雅的接口。\r\n\r\n```python\r\n>>> import requests\r\n>>> r = requests.get('https://httpbin.org/basic-auth/user/pass', auth=('user', 'pass'))\r\n>>> r.status_code\r\n200\r\n>>> r.headers['content-type']\r\n'application/json; charset=utf8'\r\n>>> r.encoding\r\n'utf-8'\r\n>>> r.text\r\n'{\"authenticated\": true, ...'\r\n>>> r.json()\r\n{'authenticated': True, ...}\r\n```\r\n","n":0.209}}},{"i":69,"$":{"0":{"v":"Pytorch","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[PyTorch](https://pypi.org/project/torch/)是一个机器学习框架。\r\n\r\n> PyTorch is a Python package that provides two high-level features:\r\n>\r\n> - Tensor computation (like NumPy) with strong GPU acceleration\r\n> - Deep neural networks built on a tape-based autograd system\r\n","n":0.18}}},{"i":70,"$":{"0":{"v":"PyQT5","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[PyQT5](https://pypi.org/project/PyQt5/)是 QT5 框架的 Python 绑定。\r\n\r\n> Qt is set of cross-platform C++ libraries that implement high-level APIs for accessing many aspects of modern desktop and mobile systems. These include location and positioning services, multimedia, NFC and Bluetooth connectivity, a Chromium based web browser, as well as traditional UI development.\r\n>\r\n> PyQt5 is a comprehensive set of Python bindings for Qt v5. It is implemented as more than 35 extension modules and enables Python to be used as an alternative application development language to C++ on all supported platforms including iOS and Android.\r\n>\r\n> PyQt5 may also be embedded in C++ based applications to allow users of those applications to configure or enhance the functionality of those applications.\r\n","n":0.093}}},{"i":71,"$":{"0":{"v":"Pydantic","n":1}}},{"i":72,"$":{"0":{"v":"Poetry","n":1},"1":{"v":"\n\r\n## 简介\r\n\r\n[Poetry](https://python-poetry.org/)是一个基于pyproject.toml的工具，利用poetry可以更加方便地进行 Python 项目的开发、构建、发布和依赖管理。\r\n\r\n## 使用\r\n\r\n参考文章[使用poetry进行Python项目开发](https://www.duyixian.cn/2020/11/23/poetry/)","n":0.447}}},{"i":73,"$":{"0":{"v":"Playwright","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[playwright](https://pypi.org/project/playwright/)是一个 Python 浏览器自动化工具，支持不同操作系统下的多款浏览器。\r\n\r\n|                        | Linux | macOS | Windows |\r\n| :--------------------- | :---: | :---: | :-----: |\r\n| Chromium 105.0.5195.19 |  ✅   |  ✅   |   ✅    |\r\n| WebKit 16.0            |  ✅   |  ✅   |   ✅    |\r\n| Firefox 103.0          |  ✅   |  ✅   |   ✅    |\r\n\r\n## 使用\r\n\r\n### 同步接口\r\n\r\n```python\r\nfrom playwright.sync_api import sync_playwright\r\n\r\nwith sync_playwright() as p:\r\n    for browser_type in [p.chromium, p.firefox, p.webkit]:\r\n        browser = browser_type.launch()\r\n        page = browser.new_page()\r\n        page.goto('http://whatsmyuseragent.org/')\r\n        page.screenshot(path=f'example-{browser_type.name}.png')\r\n        browser.close()\r\n```\r\n\r\n### 异步接口\r\n\r\n```python\r\nimport asyncio\r\nfrom playwright.async_api import async_playwright\r\n\r\nasync def main():\r\n    async with async_playwright() as p:\r\n        for browser_type in [p.chromium, p.firefox, p.webkit]:\r\n            browser = await browser_type.launch()\r\n            page = await browser.new_page()\r\n            await page.goto('http://whatsmyuseragent.org/')\r\n            await page.screenshot(path=f'example-{browser_type.name}.png')\r\n            await browser.close()\r\n\r\nasyncio.run(main())\r\n```\r\n","n":0.1}}},{"i":74,"$":{"0":{"v":"Pipenv","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[pipenv](https://pypi.org/project/pipenv/)是一个 Python 虚拟环境与包管理工具。可以理解为一个 Python 版本的 npm。\r\n\r\npipenv使用Pipfile定义项目的元信息（依赖，Python版本等）。\r\n\r\nPipfile使用[[software-develop.config.toml]]格式，下面是一个典型的[Pipfile](https://github.com/duyixian1234/fastapi-template/blob/master/Pipfile)的内容。\r\n\r\n```toml\r\n[[source]] # 设置pypi源信息\r\nurl = \"https://mirrors.tencent.com/pypi/simple\"\r\nverify_ssl = true\r\nname = \"pypi\"\r\n\r\n[packages] # 维护依赖\r\nfastapi = \"*\"\r\nuvicorn = \"*\"\r\nuvloop = \"*\"\r\nhttptools = \"*\"\r\n\r\n[dev-packages] # 维护开发依赖\r\npylint = \"*\"\r\nisort = \"*\"\r\nmypy = \"*\"\r\npytest = \"*\"\r\npytest-cov = \"*\"\r\nblack = \"*\"\r\nrequests = \"*\"\r\n\r\n[requires] # 指定Python版本\r\npython_version = \"3.9\"\r\n\r\n[pipenv] # 额外设置\r\nallow_prereleases = true\r\n\r\n```","n":0.143}}},{"i":75,"$":{"0":{"v":"Pip","n":1},"1":{"v":"\n## 升级 pip\n\n```shell\n$ python -m pip install -U pip\n```\n\n## 指定 Pypi 源\n\n### 镜像地址\n\n| 镜像   | 地址                                          |\n| ------ | --------------------------------------------- |\n| 豆瓣   | https://pypi.doubanio.com/simple/             |\n| 阿里云 | https://mirrors.aliyun.com/pypi/simple        |\n| 腾讯云 | https://mirrors.cloud.tencent.com/pypi/simple |\n\n### 安装时指定\n\n```shell\n$ pip install flask -i https://mirrors.tencent.com/pypi/simple\n```\n\n### 修改 requirements.txt\n\n第一行加入`-i https://mirrors.tencent.com/pypi/simple`\n\n### 设置为默认值\n\n修改`$HOME/.config/pip/pip.conf`\n\n```ini\n[global]\ntimeout = 60\nindex-url = https://pypi.doubanio.com/simple/\nNPM\n```\n","n":0.146}}},{"i":76,"$":{"0":{"v":"Pandas","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[Pandas](https://pypi.org/project/pandas/)是一个强大的 Python 数据分析库。\r\n\r\n> ## Main Features\r\n>\r\n> Here are just a few of the things that pandas does well:\r\n>\r\n> - Easy handling of [**missing data**](https://pandas.pydata.org/pandas-docs/stable/user_guide/missing_data.html) (represented as `NaN`, `NA`, or `NaT`) in floating point as well as non-floating point data\r\n> - Size mutability: columns can be [**inserted and deleted**](https://pandas.pydata.org/pandas-docs/stable/user_guide/dsintro.html#column-selection-addition-deletion) from DataFrame and higher dimensional objects\r\n> - Automatic and explicit [**data alignment**](https://pandas.pydata.org/pandas-docs/stable/user_guide/dsintro.html?highlight=alignment#intro-to-data-structures): objects can be explicitly aligned to a set of labels, or the user can simply ignore the labels and let `Series`, `DataFrame`, etc. automatically align the data for you in computations\r\n> - Powerful, flexible [**group by**](https://pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html#group-by-split-apply-combine) functionality to perform split-apply-combine operations on data sets, for both aggregating and transforming data\r\n> - Make it [**easy to convert**](https://pandas.pydata.org/pandas-docs/stable/user_guide/dsintro.html#dataframe) ragged, differently-indexed data in other Python and NumPy data structures into DataFrame objects\r\n> - Intelligent label-based [**slicing**](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#slicing-ranges), [**fancy indexing**](https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html#advanced), and [**subsetting**](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#boolean-indexing) of large data sets\r\n> - Intuitive [**merging**](https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html#database-style-dataframe-or-named-series-joining-merging) and [**joining**](https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html#joining-on-index) data sets\r\n> - Flexible [**reshaping**](https://pandas.pydata.org/pandas-docs/stable/user_guide/reshaping.html) and [**pivoting**](https://pandas.pydata.org/pandas-docs/stable/user_guide/reshaping.html) of data sets\r\n> - [**Hierarchical**](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#hierarchical-indexing-multiindex) labeling of axes (possible to have multiple labels per tick)\r\n> - Robust IO tools for loading data from [**flat files**](https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#csv-text-files) (CSV and delimited), [**Excel files**](https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#excel-files), [**databases**](https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#sql-queries), and saving/loading data from the ultrafast [**HDF5 format**](https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables)\r\n> - [**Time series**](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#time-series-date-functionality)-specific functionality: date range generation and frequency conversion, moving window statistics, date shifting and lagging\r\n","n":0.069}}},{"i":77,"$":{"0":{"v":"Numpy","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[numpy](https://pypi.org/project/numpy/)是一个 Python 数值计算库，用于高效处理多维数组数据。\r\n\r\n> Project description\r\n>\r\n> It provides:\r\n>\r\n> - a powerful N-dimensional array object\r\n> - sophisticated (broadcasting) functions\r\n> - tools for integrating C/C++ and Fortran code\r\n> - useful linear algebra, Fourier transform, and random number capabilities\r\n> - and much more\r\n>\r\n> Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data. Arbitrary data-types can be defined. This allows NumPy to seamlessly and speedily integrate with a wide variety of databases.\r\n>\r\n> All NumPy wheels distributed on PyPI are BSD licensed.\r\n>\r\n> NumPy requires pytest and hypothesis. Tests can then be run after installation with:\r\n>\r\n> ```\r\n> python -c 'import numpy; numpy.test()'\r\n> ```\r\n","n":0.097}}},{"i":78,"$":{"0":{"v":"Mypy","n":1}}},{"i":79,"$":{"0":{"v":"Multithreading","n":1},"1":{"v":"\n\r\n## [GIL](https://docs.python.org/zh-cn/3/glossary.html#term-global-interpreter-lock)\r\n\r\n> 在 CPython 中，由于存在 全局解释器锁，同一时刻只有一个线程可以执行 Python 代码（虽然某些性能导向的库可能会去除此限制）。 如果你想让你的应用更好地利用多核心计算机的计算资源，推荐你使用 multiprocessing 或 concurrent.futures.ProcessPoolExecutor。 但是，如果你想要同时运行多个 I/O 密集型任务，则多线程仍然是一个合适的模型。\r\n\r\n## Python多线程\r\n\r\n### threading标准库\r\n\r\n可以使用threading标准库的Thread类创建并管理线程，相对而言比较繁琐。\r\n\r\n### ThreadPoolExecutor\r\n\r\nconcurrent.futures 标准库提供了ThreadPoolExecutor类型，可以方便创建和使用线程池。\r\n\r\n#### 示例\r\n\r\n```python\r\nimport time\r\nimport requests\r\nfrom functools import partial\r\nfrom concurrent.futures import ThreadPoolExecutor\r\n\r\ndef fetch(url:str, session: requests.Session) -> int:\r\n    resp = session.get(url)\r\n    return resp.status_code\r\n\r\nwith requests.Session() as session:\r\n    start = time.time()\r\n    for x in range(100):\r\n        fetch(f'http://httpbin.org/get?a={x}', session) \r\n    print(f'For Loop Cost: {time.time()-start} seconds')\r\n\r\n# For Loop Cost: 26.713851928710938 seconds\r\n\r\nwith ThreadPoolExecutor() as pool,requests.Session() as session:\r\n    fetch_with_session = partial(fetch, session = session)\r\n    start = time.time()\r\n    list(pool.map(fetch_with_session, [f'http://httpbin.org/get?a={x}' for x in range(100)]))\r\n    print(f'ThreadPoolExecutor Cost: {time.time()-start} seconds')\r\n\r\n# ThreadPoolExecutor Cost: 3.781949758529663 seconds\r\n```","n":0.106}}},{"i":80,"$":{"0":{"v":"标准库模块","n":1},"1":{"v":"\n\r\n参考[Python 标准库](https://docs.python.org/zh-cn/3/library/index.html)\r\n\r\n## math\r\n\r\n实用的数学函数\r\n\r\n## collections\r\n\r\n提供了一些有用的容器类\r\n\r\n## functools\r\n\r\n提供了一些有用的高阶函数\r\n\r\n## itertools\r\n\r\n提供了大量的函数用于处理和生成迭代器\r\n\r\n## heapq\r\n\r\n提供了原生的二叉堆算法\r\n\r\n## bisect\r\n\r\n数组二分查找算法\r\n\r\n## dataclasses\r\n\r\n利用 Type Hint 定义数据类\r\n\r\n## pathlib\r\n\r\n优雅的文件路径处理库\r\n","n":0.277}}},{"i":81,"$":{"0":{"v":"列表（字典， 集合）推导式","n":0.707},"1":{"v":"\n\r\n## 基本用法\r\n\r\n```python\r\nassert [x for x in range(10) if x % 2] == [1, 3, 5, 7, 9]\r\nassert {x for x in range(10) if x % 2} == {1, 3, 5, 7, 9}\r\nassert {x: x**2 for x in range(10)} == {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}\r\n```\r\n\r\n## 内部实现\r\n\r\n使用`get_iter`指令，效率高于 map/filter 函数\r\n\r\n```python\r\n>>> import dis\r\n>>> dis.dis(\"[x for x in 'abc']\")\r\n1           0 LOAD_CONST               0 (<code object <listcomp> at 0x000001F3D5502E40, file \"<dis>\", line 1>)\r\n              2 LOAD_CONST               1 ('<listcomp>')\r\n              4 MAKE_FUNCTION            0\r\n              6 LOAD_CONST               2 ('abc')\r\n              8 GET_ITER\r\n             10 CALL_FUNCTION            1\r\n             12 RETURN_VALUE\r\n\r\nDisassembly of <code object <listcomp> at 0x000001F3D5502E40, file \"<dis>\", line 1>:\r\n  1           0 BUILD_LIST               0\r\n              2 LOAD_FAST                0 (.0)\r\n        >>    4 FOR_ITER                 4 (to 14)\r\n              6 STORE_FAST               1 (x)\r\n              8 LOAD_FAST                1 (x)\r\n             10 LIST_APPEND              2\r\n             12 JUMP_ABSOLUTE            2 (to 4)\r\n        >>   14 RETURN_VALUE\r\n```\r\n\r\n```python\r\n>>> import timeit\r\ncomprehension = timeit.timeit(\"[x.upper() for x in 'abc']\", number=10000)\r\nmap_function = timeit.timeit(\"list(map(str.upper, 'abc'))\", number=10000)\r\nprint(f'{comprehension=} vs {map_function=}')\r\n\r\ncomprehension=0.003946700002416037 vs map_function=0.0069931999896653\r\n```\r\n","n":0.079}}},{"i":82,"$":{"0":{"v":"迭代器","n":1},"1":{"v":"\n\r\n## 简介\r\n\r\n[迭代器类型](https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator-types)\r\n\r\n## 创建迭代器\r\n\r\n- iter 函数\r\n- [[programming-languages.python.modules#itertools]]\r\n","n":0.408}}},{"i":83,"$":{"0":{"v":"Gevent","n":1},"1":{"v":"\n## 介绍\r\n\r\n[gevent](https://pypi.org/project/gevent/)是一个基于协程的Python网络库。\r\n\r\n> gevent is a [coroutine](https://en.wikipedia.org/wiki/Coroutine) -based [Python](http://python.org/) networking library that uses [greenlet](https://greenlet.readthedocs.io/) to provide a high-level synchronous API on top of the [libev](http://software.schmorp.de/pkg/libev.html) or [libuv](http://libuv.org/) event loop.\r\n>\r\n> Features include:\r\n>\r\n> * Fast event loop based on [libev](http://software.schmorp.de/pkg/libev.html) or [libuv](http://libuv.org/).\r\n> * Lightweight execution units based on greenlets.\r\n> * API that re-uses concepts from the Python standard library (for examples there are [events](http://www.gevent.org/api/gevent.event.html#gevent.event.Event) and [queues](http://www.gevent.org/api/gevent.queue.html#gevent.queue.Queue)).\r\n> * [Cooperative sockets with SSL support](http://www.gevent.org/api/index.html#networking)\r\n> * [Cooperative DNS queries](http://www.gevent.org/dns.html) performed through a threadpool, dnspython, or c-ares.\r\n> * [Monkey patching utility](http://www.gevent.org/intro.html#monkey-patching) to get 3rd party modules to become cooperative\r\n> * TCP/UDP/HTTP servers\r\n> * Subprocess support (through [gevent.subprocess](http://www.gevent.org/api/gevent.subprocess.html#module-gevent.subprocess))\r\n> * Thread pools\r\n>\r\n> gevent is [inspired by eventlet](http://blog.gevent.org/2010/02/27/why-gevent/) but features a more consistent API, simpler implementation and better performance. Read why others [use gevent](http://groups.google.com/group/gevent/browse_thread/thread/4de9703e5dca8271) and check out the list of the [open source projects based on gevent](https://github.com/gevent/gevent/wiki/Projects).\r\n\r\n## 应用\r\n\r\n- gunicorn\r\n- celery\r\n","n":0.085}}},{"i":84,"$":{"0":{"v":"生成器","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[生成器类型](https://docs.python.org/zh-cn/3/library/stdtypes.html#generator-types)\r\n\r\n## yield 表达式\r\n\r\n[yield 表达式](https://docs.python.org/zh-cn/3/reference/expressions.html#yield-expressions)\r\n\r\n## 特点\r\n\r\n- 惰性计算\r\n- 节省内存\r\n\r\n## 示例\r\n\r\n```python\r\nimport itertools\r\n\r\n\r\ndef fib():\r\n    a, b = 1, 1\r\n    while True:\r\n        yield a\r\n        a, b = b, a + b\r\n\r\nassert list(itertools.takewhile(lambda x: x < 100, fib())) == [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\r\n```\r\n","n":0.149}}},{"i":85,"$":{"0":{"v":"Flask","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[Flask](https://pypi.org/project/Flask/)是一个 Python Web 框架。\r\n\r\n> Flask is a lightweight [WSGI](https://wsgi.readthedocs.io/) web application framework. It is designed to make getting started quick and easy, with the ability to scale up to complex applications. It began as a simple wrapper around [Werkzeug](https://werkzeug.palletsprojects.com/) and [Jinja](https://jinja.palletsprojects.com/) and has become one of the most popular Python web application frameworks.\r\n\r\n## 特点\r\n\r\n- 微框架\r\n- 基于[Werkzeug](https://werkzeug.palletsprojects.com/) WSGI 框架 与 [Jinja](https://jinja.palletsprojects.com/)模板\r\n- 可以通过第三方扩展增强功能\r\n\r\n## 资源\r\n\r\n![[resources.books#Flask:#*]]\r\n","n":0.126}}},{"i":86,"$":{"0":{"v":"FastAPI","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[FastAPI](https://pypi.org/project/fastapi/)是一个新兴的 Python Web 框架。\r\n\r\n> FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.6+ based on standard Python type hints.\r\n>\r\n> The key features are:\r\n>\r\n> - **Fast** : Very high performance, on par with **NodeJS** and **Go** (thanks to Starlette and Pydantic). [One of the fastest Python frameworks available](https://pypi.org/project/fastapi/#performance).\r\n> - **Fast to code** : Increase the speed to develop features by about 200% to 300%. \\*\r\n> - **Fewer bugs** : Reduce about 40% of human (developer) induced errors. \\*\r\n> - **Intuitive** : Great editor support. Completion everywhere. Less time debugging.\r\n> - **Easy** : Designed to be easy to use and learn. Less time reading docs.\r\n> - **Short** : Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs.\r\n> - **Robust** : Get production-ready code. With automatic interactive documentation.\r\n> - **Standards-based** : Based on (and fully compatible with) the open standards for APIs: [OpenAPI](https://github.com/OAI/OpenAPI-Specification) (previously known as Swagger) and [JSON Schema](https://json-schema.org/).\r\n","n":0.08}}},{"i":87,"$":{"0":{"v":"Django","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[Django](https://pypi.org/project/Django/)是一个 Python Web 开发框架。\r\n\r\n## 特点\r\n\r\n- 大而全\r\n- 自带 ORM 与模板渲染\r\n- 适用于关系型数据库\r\n\r\n## 资源\r\n\r\n![[resources.books#Django:#*]]\r\n","n":0.289}}},{"i":88,"$":{"0":{"v":"装饰器","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n> decorator -- 装饰器返回值为另一个函数的函数，通常使用 `@wrapper` 语法形式来进行函数变换。装饰器的常见例子包括 `classmethod` 和 `staticmethod`。\r\n>\r\n> 装饰器语法只是一种语法糖，以下两个函数定义在语义上完全等价:\r\n>\r\n> ```python\r\n> def f(arg):\r\n>     ...\r\n> f = staticmethod(f)\r\n>\r\n> @staticmethod\r\n> def f(arg):\r\n>     ...\r\n> ```\r\n\r\n## 示例\r\n\r\n```python\r\ndef log_call(func):\r\n    def wrapper(*args, **kwargs):\r\n        print(f'Function {func.__name__} Called With ({args}, {kwargs})')\r\n        return func(*args, **kwargs)\r\n    return wrapper\r\n\r\n@log_call\r\ndef add(x, y):\r\n    return x + y\r\n\r\nassert add(1, 2) == 3 # Function add Called With ((1, 2), {})\r\n```\r\n","n":0.132}}},{"i":89,"$":{"0":{"v":"上下文管理器","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[RAII 概念与在 Python 中的应用 | 那时难决 (duyixian.cn)](https://www.duyixian.cn/2021/08/22/RAII/)\r\n\r\n## 示例\r\n\r\n```python\r\nclass MyContextManager:\r\n    def __init__(self):\r\n        self.used = False\r\n    def __enter__(self):\r\n        print('entering')\r\n        self.used = True\r\n        return self\r\n    def __exit__(self, exc_type, exc_val, exc_tb):\r\n        print('exiting')\r\n\r\nwith MyContextManager() as cm:\r\n    print('in context')\r\n    assert cm.used\r\n```\r\n","n":0.167}}},{"i":90,"$":{"0":{"v":"Click","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[click](https://pypi.org/project/click/)是一个用于开发命令行程序的 Python 包。\r\n\r\n> Click is a Python package for creating beautiful command line interfaces in a composable way with as little code as necessary. It’s the “Command Line Interface Creation Kit”. It’s highly configurable but comes with sensible defaults out of the box.\r\n>\r\n> It aims to make the process of writing command line tools quick and fun while also preventing any frustration caused by the inability to implement an intended CLI API.\r\n>\r\n> Click in three points:\r\n>\r\n> - Arbitrary nesting of commands\r\n> - Automatic help page generation\r\n> - Supports lazy loading of subcommands at runtime\r\n\r\n## 使用\r\n\r\n```python\r\nimport click\r\n\r\n@click.command()\r\n@click.option(\"--count\", default=1, help=\"Number of greetings.\")\r\n@click.option(\"--name\", prompt=\"Your name\", help=\"The person to greet.\")\r\ndef hello(count, name):\r\n    \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\"\r\n    for _ in range(count):\r\n        click.echo(f\"Hello, {name}!\")\r\n\r\nif __name__ == '__main__':\r\n    hello()\r\n```\r\n\r\n```shell\r\n$ python hello.py --count=3\r\nYour name: Click\r\nHello, Click!\r\nHello, Click!\r\nHello, Click!\r\n```\r\n","n":0.085}}},{"i":91,"$":{"0":{"v":"内置类型","n":1},"1":{"v":"\n\r\n参考[【使用 Python 实现算法】02 原生类型与内置函数 | 那时难决 (duyixian.cn)](https://www.duyixian.cn/2022/06/27/2022-06-27%20algorithms%20in%20python%2002/#int)\r\n\r\n## int\r\n\r\n- int.bit_count\r\n- int.bit_length\r\n\r\n## float\r\n\r\n- float.as_integer_ration\r\n- 格式化：`f\"{1/3:.4f}\" == \"0.3333\" `\r\n\r\n## list\r\n\r\n- 获取并删除指定位置的元素（O(n)复杂度）：list.pop(n)\r\n\r\n## tuple\r\n\r\n- tuple 对象可以作为字典的键\r\n\r\n## dict\r\n\r\n- dict.fromkeys\r\n- 可使用[[字典推导式|programming-languages.python.list comprehension]]初始化 dict：`{ch: count for ch, count in [(\"a\", 1), (\"b\", 2), (\"c\", 3)]} == {\"a\": 1, \"b\": 2, \"c\": 3}`\r\n- 可使用`|`合并 dict，`{1: 2, 2: 3} | {2: 4, 3: 5} == {1: 2, 2: 4, 3: 5}`\r\n\r\n## set\r\n\r\n- 可使用[[集合推导式|programming-languages.python.list comprehension]]初始化 set：`{x for x in range(10) if x % 2 == 0} == {0, 2, 4, 6, 8}`\r\n- set 支持的一些运算符：`&` `|` `-` `>` `>=` `<` `<=`\r\n\r\n## str\r\n\r\n- 使用各类 str.isxxx 方法检查字符串内容\r\n- str.partition： `assert \"A B C\".partition(\" \") == (\"A\", \" \", \"B C\") `\r\n","n":0.097}}},{"i":92,"$":{"0":{"v":"内置函数","n":1},"1":{"v":"\n\r\n参考[【使用 Python 实现算法】02 原生类型与内置函数 | 那时难决 (duyixian.cn)](https://www.duyixian.cn/2022/06/27/2022-06-27%20algorithms%20in%20python%2002/#int)\r\n\r\n## round\r\n\r\nPython 的 round 实现为银行家算法，四舍六入五成双\r\n\r\n```python\r\nassert round(1.2) == 1\r\nassert round(1.6) == 2\r\nassert round(1.5) == 2\r\nassert round(2.5) == 2\r\n```\r\n\r\n## all, any\r\n\r\n会提前返回\r\n\r\n## next\r\n\r\n可以应用在获取第一个符合条件的元素的场景。\r\n\r\n```python\r\nassert next(x for x in range(1, 10) if x % 3 == 0) == 3\r\n```\r\n\r\n## enumerate\r\n\r\n```python\r\nfor index, ch in enumerate(\"abc\"):\r\n    pass\r\n```\r\n\r\n## map, filter\r\n\r\n返回一个[[迭代器 | programming-languages.python.iterators]]，可使用列表推导式替换\r\n\r\n## sorted\r\n\r\n返回的是一个 list\r\n\r\n## zip\r\n\r\n可用于初始化 dict\r\n\r\n```python\r\nassert dict(zip('abcd', range(4))) == {'a': 0, 'b': 1, 'c': 2, 'd': 3}\r\n```\r\n\r\n可以使用 zip 进行矩阵转置。\r\n\r\n```python\r\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\r\nassert [list(row) for row in zip(*matrix)] == [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\r\n```\r\n","n":0.104}}},{"i":93,"$":{"0":{"v":"Asyncio","n":1},"1":{"v":"\n## 介绍\r\n\r\n[asyncio](https://docs.python.org/zh-cn/3/library/asyncio.html)是 Python 原生的协程标准库。\r\n\r\n> asyncio 是用来编写 **并发** 代码的库，使用 **async/await** 语法。\r\n>\r\n> asyncio 被用作多个提供高性能 Python 异步框架的基础，包括网络和网站服务，数据库连接库，分布式任务队列等等。\r\n>\r\n> asyncio 往往是构建 IO 密集型和高层级 **结构化** 网络代码的最佳选择。\r\n>\r\n> asyncio 提供一组 **高层级** API 用于:\r\n>\r\n> - 并发地 [**运行 Python 协程**](https://docs.python.org/zh-cn/3/library/asyncio-task.html#coroutine) 并对其执行过程实现完全控制;\r\n> - 执行 [**网络 IO 和 IPC**](https://docs.python.org/zh-cn/3/library/asyncio-stream.html#asyncio-streams);\r\n> - 控制 [**子进程**](https://docs.python.org/zh-cn/3/library/asyncio-subprocess.html#asyncio-subprocess);\r\n> - 通过 [**队列**](https://docs.python.org/zh-cn/3/library/asyncio-queue.html#asyncio-queues) 实现分布式任务;\r\n> - [**同步**](https://docs.python.org/zh-cn/3/library/asyncio-sync.html#asyncio-sync) 并发代码;\r\n>\r\n> 此外，还有一些 **低层级** API 以支持 _库和框架的开发者_ 实现:\r\n>\r\n> - 创建和管理 [**事件循环**](https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio-event-loop)，以提供异步 API 用于 [<span class=\"pre\">网络化</span>](https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.create_server \"asyncio.loop.create_server\"), 运行 [<span class=\"pre\">子进程</span>](https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.subprocess_exec \"asyncio.loop.subprocess_exec\")，处理 [<span class=\"pre\">OS</span><span> </span><span class=\"pre\">信号</span>](https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.add_signal_handler \"asyncio.loop.add_signal_handler\") 等等;\r\n> - 使用 [**transports**](https://docs.python.org/zh-cn/3/library/asyncio-protocol.html#asyncio-transports-protocols) 实现高效率协议;\r\n> - 通过 async/await 语法 [**桥接**](https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio-futures) 基于回调的库和代码。\r\n\r\n## 生态\r\n\r\n- ASGI（[[programming-languages.python.FastAPI]]）\r\n- [timofurrer/awesome-asyncio](https://github.com/timofurrer/awesome-asyncio)\r\n","n":0.109}}},{"i":94,"$":{"0":{"v":"Ansible","n":1},"1":{"v":"\n\r\n## 介绍\r\n\r\n[ansible](https://pypi.org/project/ansible/)是一个基于 Python 的自动化运维工具\r\n\r\n> Ansible is a radically simple IT automation system. It handles configuration management, application deployment, cloud provisioning, ad-hoc task execution, network automation, and multi-node orchestration. Ansible makes complex changes like zero-downtime rolling updates with load balancers easy. More information on the Ansible [website](https://ansible.com/).\r\n\r\n## 资源\r\n\r\n![[resources.books#ansible:#*]]\r\n","n":0.146}}},{"i":95,"$":{"0":{"v":"面向对象编程","n":1}}},{"i":96,"$":{"0":{"v":"元编程","n":1}}},{"i":97,"$":{"0":{"v":"JavaScript","n":1}}},{"i":98,"$":{"0":{"v":"Java","n":1}}},{"i":99,"$":{"0":{"v":"Golang","n":1}}},{"i":100,"$":{"0":{"v":"函数式编程","n":1}}},{"i":101,"$":{"0":{"v":"编程语言分类","n":1}}},{"i":102,"$":{"0":{"v":"C","n":1}}},{"i":103,"$":{"0":{"v":"C++","n":1}}},{"i":104,"$":{"0":{"v":"C#","n":1}}},{"i":105,"$":{"0":{"v":"开源","n":1}}},{"i":106,"$":{"0":{"v":"开源协议","n":1}}},{"i":107,"$":{"0":{"v":"数据库","n":1}}},{"i":108,"$":{"0":{"v":"Time Series Databases","n":0.577}}},{"i":109,"$":{"0":{"v":"Relational Database","n":0.707}}},{"i":110,"$":{"0":{"v":"SQLLite","n":1}}},{"i":111,"$":{"0":{"v":"MySQL","n":1}}},{"i":112,"$":{"0":{"v":"ORMs","n":1}}},{"i":113,"$":{"0":{"v":"NoSQL","n":1}}},{"i":114,"$":{"0":{"v":"MongoDB","n":1}}},{"i":115,"$":{"0":{"v":"Indexes","n":1}}},{"i":116,"$":{"0":{"v":"Graph Databases","n":0.707}}},{"i":117,"$":{"0":{"v":"CAP","n":1}}},{"i":118,"$":{"0":{"v":"ACID","n":1}}},{"i":119,"$":{"0":{"v":"基础知识","n":1},"1":{"v":"\n\r\n## 参考\r\n\r\n![[resources.books#基础]]\r\n","n":0.707}}},{"i":120,"$":{"0":{"v":"软件","n":1}}},{"i":121,"$":{"0":{"v":"操作系统","n":1},"1":{"v":"\n## 核心\r\n\r\n- 资源虚拟化\r\n- 并发\r\n- 持久性\r\n\r\n## 设计目标\r\n\r\n- 建立抽象\r\n- 高性能\r\n- 提供保护\r\n\r\n\r\n## 资源\r\n\r\n![[resources.books#操作系统:#*]]\r\n","n":0.316}}},{"i":122,"$":{"0":{"v":"Threads And Concurrency","n":0.577}}},{"i":123,"$":{"0":{"v":"Process Management","n":0.707},"1":{"v":"\n\r\n## 概念\r\n\r\n操作系统为正在运行的程序提供的抽象。\r\n\r\n### 机器状态\r\n\r\n进程需要知晓程序的机器状态\r\n\r\n- 内存（代码和数据）\r\n- 寄存器\r\n\r\n### 进程状态\r\n\r\n![进程状态](https://res.weread.qq.com/wrepub/epub_30179184_6)\r\n\r\n### Unix 进程 API\r\n\r\n- fork 调用\r\n- wait 调用\r\n- exec 调用\r\n\r\n### 用户模式与内核模式\r\n\r\n> 硬件通过提供不同的执行模式来协助操作系统。在用户模式（user mode）下，应用程序不能完全访问硬件资源。在内核模式（kernel mode）下，操作系统可以访问机器的全部资源。还提供了陷入（trap）内核和从陷阱返回（return-from-trap）到用户模式程序的特别说明，以及一些指令，让操作系统告诉硬件陷阱表（trap table）在内存中的位置。\r\n\r\n### 时钟中断\r\n\r\n> 时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统重新获得 CPU 的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。\r\n\r\n## 进程调度\r\n\r\n### 周转时间\r\n\r\n- 先进先出（FIFO）\r\n- 最短任务优先（SJF）\r\n- 最短完成时间优先（STCF）\r\n\r\n### 响应时间\r\n\r\n- 轮转\r\n\r\n### 多级反馈队列（Multi-level Feedback Queue，MLFQ）\r\n\r\n- 规则1：如果A的优先级 > B的优先级，运行A（不运行B）。\r\n- 规则2：如果A的优先级 = B的优先级，轮转运行A和B。\r\n- 规则3：工作进入系统时，放在最高优先级（最上层队列）。\r\n- 规则4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。\r\n- 规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列。（应对饥饿问题）\r\n\r\n> MLFQ有趣的原因是：它不需要对工作的运行方式有先验知识，而是通过观察工作的运行来给出对应的优先级。通过这种方式，MLFQ可以同时满足各种工作的需求：对于短时间运行的交互型工作，获得类似于SJF/STCF的很好的全局性能，同时对长时间运行的CPU密集型负载也可以公平地、不断地稳步向前。因此，许多系统使用某种类型的MLFQ作为自己的基础调度程序，包括类BSD UNIX系统[LM+89，B86]、Solaris[M06]以及Windows NT和其后的Window系列操作系统。\r\n\r\n### 多处理器进程调度\r\n\r\n- 单队列\r\n- 多队列\r\n- 进程迁移","n":0.14}}},{"i":124,"$":{"0":{"v":"POSIX Basics","n":0.707}}},{"i":125,"$":{"0":{"v":"Memory Management","n":0.707},"1":{"v":"\n\r\n## 虚拟内存\r\n\r\n### 目标\r\n\r\n- 透明\r\n- 效率\r\n- 保护\r\n\r\n## 类型\r\n\r\n### 栈内存\r\n\r\n### 堆内存\r\n\r\n- malloc 调用\r\n- free 调用\r\n\r\n### 错误\r\n\r\n- segment fault 忘记分配内存\r\n- buffer overflow 缓冲区溢出 安全风险\r\n- uninitialized read\r\n- memory leak 内存泄漏\r\n- dangling pointer 悬垂指针\r\n- double free 重复释放\r\n- invalid free 无效释放\r\n\r\n## 内存管理\r\n\r\n### 地址转换\r\n\r\n#### dynamic relocation 动态重定位\r\n\r\n```\r\nphysical address = virtual address + base\r\n```\r\n\r\n![os-memory-management](https://res.weread.qq.com/wrepub/epub_30179184_52)\r\n\r\n### 分段\r\n\r\n### 空闲空间管理\r\n\r\n- 最优匹配\r\n- 最差匹配\r\n- 首次匹配\r\n- 下次匹配\r\n\r\n[Linux 内存管理中的 slab 分配器 ](https://www.cnblogs.com/pengdonglin137/p/3878552.html)\r\n\r\n### 分页\r\n\r\n![分页](https://res.weread.qq.com/wrepub/epub_30179184_85)\r\n\r\n> #### 数据结构——页表\r\n>\r\n> 现代操作系统的内存管理子系统中最重要的数据结构之一就是页表（page table）。通常，页表存储虚拟—物理地址转换（virtual-to-physical address translation），从而让系统知道地址空间的每个页实际驻留在物理内存中的哪个位置。由于每个地址空间都需要这种转换，因此一般来说，系统中每个进程都有一个页表。页表的确切结构要么由硬件（旧系统）确定，要么由 OS（现代系统）更灵活地管理。\r\n\r\n#### 交换空间","n":0.124}}},{"i":126,"$":{"0":{"v":"IO Management","n":0.707},"1":{"v":"\n\r\n![系统架构](https://res.weread.qq.com/wrepub/epub_30179184_142)\r\n\r\n## DMA(Direct Memory Access)\r\n\r\n## 设备驱动程序\r\n\r\n大部分操作系统内核代码都是驱动程序。\r\n\r\n## 磁盘驱动器\r\n\r\n平均寻道时间\r\n\r\n### 磁盘调度\r\n\r\n- 最短寻道时间优先\r\n- 电梯算法（C-SCAN）\r\n\r\n## 廉价冗余磁盘阵列（RAID）\r\n\r\n- RAID 0(条带化)\r\n- RAID 1(镜像)\r\n- RAID 4(奇偶校验)\r\n- RAID 5(旋转奇偶校验)\r\n\r\n![RAID](https://res.weread.qq.com/wrepub/epub_30179184_187)\r\n\r\n## 文件系统\r\n\r\n- 文件\r\n- 目录\r\n- inode\r\n- open 调用\r\n- 文件描述符\r\n- fsync 调用\r\n- 硬链接，软链接，unlink\r\n- 文件系统检查程序（fsck）与日志\r\n- ext3/ext4，NTFS，btrfs\r\n\r\n> inode 是许多文件系统中使用的通用名称，用于描述保存给定文件的元数据的结构，例如其长度、权限以及其组成块的位置。这个名称至少可以追溯到 UNIX（如果不是早期的系统，可能还会追溯到 Multics）。它是 index node（索引节点）的缩写，因为 inode 号用于索引磁盘上的 inode 数组，以便查找该 inode 号对应的 inode。我们将看到，inode 的设计是文件系统设计的一个关键部分。大多数现代系统对于它们记录的每个文件都有这样的结构，但也许用了不同的名字（如 dnodes、fnodes 等）。\r\n\r\n### 数据完整性与保护\r\n\r\n- 校验和\r\n","n":0.144}}},{"i":127,"$":{"0":{"v":"Interprocess Communication","n":0.707}}},{"i":128,"$":{"0":{"v":"Concurrent","n":1},"1":{"v":"\n## 线程\n\n- 独立寄存器\n- 共享地址空间\n- 使用线程控制块 Thread Control Block 维护状态\n- 独立栈空间（Thread Local）\n\n### 线程 API\n\n- 创建\n- 完成（join）\n- 互斥量\n- 条件变量\n\n---\n\n## 线程安全\n\n- 临界区（访问共享资源的代码）\n- 竞态条件（多个线程进入临界区）\n- 互斥执行\n- 原子操作\n\n## 锁\n\nPthread 锁（mutex）\n\n### 特性\n\n- 提供互斥\n- 公平性\n- 性能\n\n### 原子指令\n\n- test-and-set\n- compare-and-set\n- fetch-and-set\n\n### 自旋锁\n\n需要主动让出 CPU 以避免其他线程饿死\n\n> 提示：更多并发不一定更快\n>\n> 如果方案带来了大量的开销（例如，频繁地获取锁、释放锁），那么高并发就没有什么意义。如果简单的方案很少用到高开销的调用，通常会很有效。增加更多的锁和复杂性可能会适得其反。话虽如此，有一种办法可以获得真知：实现两种方案（简单但少一点并发，复杂但多一点并发），测试它们的表现。毕竟，你不能在性能上作弊。结果要么更快，要么不快。\n\n### 信号量\n\n- 二值信号量（锁）\n- 信号量可作为条件变量\n- 生产者/消费者问题（有界缓冲区）\n- 哲学家就餐\n\n## 常见并发问题\n\n### 非死锁缺陷\n\n- 违反原子性缺陷\n- 违反顺序缺陷\n\n### 死锁缺陷\n\n#### 产生死锁的条件\n\n- 互斥\n- 占有并等待\n- 非抢占\n- 循环等待\n\n#### 预防和避免死锁\n\n- 避免循环等待\n- wait-free 数据结构\n- 检查和回复\n\n## 基于事件的并发\n\nnode.js\n\n### 事件循环\n\n- select(poll)\n- 异步 I/O\n- 状态管理\n","n":0.126}}},{"i":129,"$":{"0":{"v":"硬件","n":1},"1":{"v":"\n\r\n## 早期计算设备\r\n\r\n- 算盘\r\n- 计算尺\r\n- 雅各提花织机（可编程）\r\n- 差分机\r\n\r\n## 电子计算机\r\n\r\n- ENIAC\r\n- EDSAC\r\n\r\n## 计算机组成\r\n\r\n- [[basic.hardware.cpu]]\r\n- [[basic.hardware.storage]]\r\n- [[basic.hardware.IO Devices]]\r\n","n":0.267}}},{"i":130,"$":{"0":{"v":"存储","n":1}}},{"i":131,"$":{"0":{"v":"RAM","n":1}}},{"i":132,"$":{"0":{"v":"Hard Disks And Secondary Storage","n":0.447}}},{"i":133,"$":{"0":{"v":"IO Devices","n":0.707}}},{"i":134,"$":{"0":{"v":"CPU","n":1}}},{"i":135,"$":{"0":{"v":"逻辑门","n":1}}},{"i":136,"$":{"0":{"v":"集成电路","n":1}}},{"i":137,"$":{"0":{"v":"Instrution Set","n":0.707},"1":{"v":"\n\r\n## RISC 与 CISC\r\n\r\n> 在 20 世纪 80 年代，计算机体系结构领域曾发生过一场激烈的讨论。一方是 CISC 阵营，即复杂指令集计算（Complex Instruction Set Computing），另一方是 RISC，即精简指令集计算（Reduced Instruction Set Computing）[PS81]。RISC 阵营以 Berkeley 的 David Patterson 和 Stanford 的 John Hennessy 为代表（他们写了一些非常著名的书[HP06]），尽管后来 John Cocke 凭借他在 RISC 上的早期工作 [CM00]获得了图灵奖。\r\n>\r\n> CISC 指令集倾向于拥有许多指令，每条指令比较强大。例如，你可能看到一个字符串拷贝，它接受两个指针和一个长度，将一些字节从源拷贝到目标。CISC 背后的思想是，指令应该是高级原语，这让汇编语言本身更易于使用，代码更紧凑。\r\n>\r\n> RISC 指令集恰恰相反。RISC 背后的关键观点是，指令集实际上是编译器的最终目标，所有编译器实际上需要少量简单的原语，可以用于生成高性能的代码。因此，RISC 倡导者们主张，尽可能从硬件中拿掉不必要的东西（尤其是微代码），让剩下的东西简单、统一、快速。\r\n>\r\n> 早期的 RISC 芯片产生了巨大的影响，因为它们明显更快[BC91]。人们写了很多论文，一些相关的公司相继成立（例如 MIPS 和 Sun 公司）。但随着时间的推移，像 Intel 这样的 CISC 芯片制造商采纳了许多 RISC 芯片的优点，例如添加了早期流水线阶段，将复杂的指令转换为一些微指令，于是它们可以像 RISC 的方式运行。这些创新，加上每个芯片中晶体管数量的增长，让 CISC 保持了竞争力。争论最后平息了，现在两种类型的处理器都可以跑得很快。\r\n","n":0.13}}},{"i":138,"$":{"0":{"v":"通信","n":1}}},{"i":139,"$":{"0":{"v":"网络","n":1}}},{"i":140,"$":{"0":{"v":"UDP","n":1}}},{"i":141,"$":{"0":{"v":"TCP","n":1}}},{"i":142,"$":{"0":{"v":"HTTPS","n":1}}},{"i":143,"$":{"0":{"v":"HTTP","n":1}}},{"i":144,"$":{"0":{"v":"DNS","n":1}}},{"i":145,"$":{"0":{"v":"压缩","n":1}}},{"i":146,"$":{"0":{"v":"编码","n":1}}},{"i":147,"$":{"0":{"v":"架构","n":1}}},{"i":148,"$":{"0":{"v":"Domain Driven Design","n":0.577}}},{"i":149,"$":{"0":{"v":"Cloud Native","n":0.707}}},{"i":150,"$":{"0":{"v":"PaaS","n":1}}},{"i":151,"$":{"0":{"v":"IaaS","n":1}}},{"i":152,"$":{"0":{"v":"FaaS","n":1}}},{"i":153,"$":{"0":{"v":"关于我","n":1},"1":{"v":"\r\n## 简介\r\n\r\n我是[杜逸先](https://github.com/duyixian1234)，95 年出生的陕西汉子，17 年毕业于浙江大学软件工程专业，目前作为一个研发工程师生活在杭州。\r\n\r\n## 个人网站\r\n\r\n- [博客](https://www.duyixian.cn)\r\n\r\n## 技能\r\n\r\n### 基础\r\n\r\n- [[basic.software.operating-system]]\r\n- [[basic.communication.network]]\r\n- [[basic.hardware]]\r\n\r\n### 编程语言\r\n\r\n| 编程语言                             | 熟练度 | 认可度 | 使用频率 |\r\n| ------------------------------------ | :----: | ------ | :------- |\r\n| [[programming-languages.python]]     | ★★★★★  | ★★★★★  | 日常工作 |\r\n| [[programming-languages.javascript]] |  ★★★   | ★★     | 日常工作 |\r\n| [[programming-languages.typescript]] |  ★★★   | ★★★★★  | 日常工作 |\r\n| [[programming-languages.java]]       |  ★★★   | ★★★★   | 偶尔     |\r\n| [[programming-languages.c]]          |  ★★★   | ★★★★   | 偶尔     |\r\n| [[programming-languages.c++]]        |  ★★★   | ★★★★   | 偶尔     |\r\n| [[programming-languages.rust]]       |   ★★   | ★★★★★  | 兴趣学习 |\r\n| [[programming-languages.golang]]     |   ★    | ★★★    | 兴趣学习 |\r\n\r\n### 框架\r\n\r\n#### 后端框架\r\n\r\n| 框架                                                  | 熟练度 | 认可度 | 使用频率 |\r\n| ----------------------------------------------------- | ------ | ------ | -------- |\r\n| [Flask](https://flask.palletsprojects.com/en/2.2.x/)  | ★★★★★  | ★★★★★  | 日常工作 |\r\n| [FastAPI](https://fastapi.tiangolo.com)               | ★★★★   | ★★★★★  | 日常工作 |\r\n| [Spring Boot](https://spring.io/projects/spring-boot) | ★★★    | ★★★★★  | 偶尔     |\r\n\r\n#### 前端框架\r\n\r\n| 框架                             | 熟练度 | 认可度 | 使用频率 |\r\n| -------------------------------- | ------ | ------ | -------- |\r\n| [React.js](https://reactjs.org/) | ★★★    | ★★★★★  | 日常工作 |\r\n| [Angular](https://angular.io/)   | ★★★    | ★★★★   | 兴趣学习 |\r\n\r\n### 软件开发\r\n\r\n- [[software-develop.design.TDD]]\r\n- [[software-develop.refactoring]]\r\n- [[programming-languages.functional programming]]\r\n\r\n### DevOps\r\n\r\n- [[software-develop.CI]] [[software-develop.CD]]\r\n- [[software-develop.VCS.git]]\r\n- [Docker](https://www.docker.com/)\r\n- [Docker Compose](https://docs.docker.com/compose/)\r\n- [Kubernetes](https://kubernetes.io/)\r\n\r\n#### 平台与工具\r\n\r\n- [GitHub](https://github.com/)\r\n- [Visual Studio Code](https://code.visualstudio.com/)\r\n\r\n## 项目经历\r\n\r\n| 项目               | 技术栈                  | 内容 | 挑战 |\r\n| ------------------ | ----------------------- | ---- | ---- |\r\n| GIS 算法           | Java                    | ——   | ——   |\r\n| GIS 资源平台       | Spring Boot             | ——   | ——   |\r\n| 抽奖平台           | Python Flask Celery     | ——   | ——   |\r\n| 互动玩法           | Python Flask Celery     | ——   | ——   |\r\n| 签到系统           | Python Flask Celery     | ——   | ——   |\r\n| 低代码页面配置系统 | Python Fastapi Dramatiq | ——   | ——   |\r\n| 游戏               | Node.js TypeScript      | ——   | ——   |\r\n","n":0.061}}}]}
