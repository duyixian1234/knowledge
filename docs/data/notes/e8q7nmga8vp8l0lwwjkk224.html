<h1 id="concurrent"><a aria-hidden="true" class="anchor-heading icon-link" href="#concurrent"></a>Concurrent</h1>
<h2 id="线程"><a aria-hidden="true" class="anchor-heading icon-link" href="#线程"></a>线程</h2>
<ul>
<li>独立寄存器</li>
<li>共享地址空间</li>
<li>使用线程控制块 Thread Control Block 维护状态</li>
<li>独立栈空间（Thread Local）</li>
</ul>
<h3 id="线程-api"><a aria-hidden="true" class="anchor-heading icon-link" href="#线程-api"></a>线程 API</h3>
<ul>
<li>创建</li>
<li>完成（join）</li>
<li>互斥量</li>
<li>条件变量</li>
</ul>
<hr>
<h2 id="线程安全"><a aria-hidden="true" class="anchor-heading icon-link" href="#线程安全"></a>线程安全</h2>
<ul>
<li>临界区（访问共享资源的代码）</li>
<li>竞态条件（多个线程进入临界区）</li>
<li>互斥执行</li>
<li>原子操作</li>
</ul>
<h2 id="锁"><a aria-hidden="true" class="anchor-heading icon-link" href="#锁"></a>锁</h2>
<p>Pthread 锁（mutex）</p>
<h3 id="特性"><a aria-hidden="true" class="anchor-heading icon-link" href="#特性"></a>特性</h3>
<ul>
<li>提供互斥</li>
<li>公平性</li>
<li>性能</li>
</ul>
<h3 id="原子指令"><a aria-hidden="true" class="anchor-heading icon-link" href="#原子指令"></a>原子指令</h3>
<ul>
<li>test-and-set</li>
<li>compare-and-set</li>
<li>fetch-and-set</li>
</ul>
<h3 id="自旋锁"><a aria-hidden="true" class="anchor-heading icon-link" href="#自旋锁"></a>自旋锁</h3>
<p>需要主动让出 CPU 以避免其他线程饿死</p>
<blockquote>
<p>提示：更多并发不一定更快</p>
<p>如果方案带来了大量的开销（例如，频繁地获取锁、释放锁），那么高并发就没有什么意义。如果简单的方案很少用到高开销的调用，通常会很有效。增加更多的锁和复杂性可能会适得其反。话虽如此，有一种办法可以获得真知：实现两种方案（简单但少一点并发，复杂但多一点并发），测试它们的表现。毕竟，你不能在性能上作弊。结果要么更快，要么不快。</p>
</blockquote>
<h3 id="信号量"><a aria-hidden="true" class="anchor-heading icon-link" href="#信号量"></a>信号量</h3>
<ul>
<li>二值信号量（锁）</li>
<li>信号量可作为条件变量</li>
<li>生产者/消费者问题（有界缓冲区）</li>
<li>哲学家就餐</li>
</ul>
<h2 id="常见并发问题"><a aria-hidden="true" class="anchor-heading icon-link" href="#常见并发问题"></a>常见并发问题</h2>
<h3 id="非死锁缺陷"><a aria-hidden="true" class="anchor-heading icon-link" href="#非死锁缺陷"></a>非死锁缺陷</h3>
<ul>
<li>违反原子性缺陷</li>
<li>违反顺序缺陷</li>
</ul>
<h3 id="死锁缺陷"><a aria-hidden="true" class="anchor-heading icon-link" href="#死锁缺陷"></a>死锁缺陷</h3>
<h4 id="产生死锁的条件"><a aria-hidden="true" class="anchor-heading icon-link" href="#产生死锁的条件"></a>产生死锁的条件</h4>
<ul>
<li>互斥</li>
<li>占有并等待</li>
<li>非抢占</li>
<li>循环等待</li>
</ul>
<h4 id="预防和避免死锁"><a aria-hidden="true" class="anchor-heading icon-link" href="#预防和避免死锁"></a>预防和避免死锁</h4>
<ul>
<li>避免循环等待</li>
<li>wait-free 数据结构</li>
<li>检查和回复</li>
</ul>
<h2 id="基于事件的并发"><a aria-hidden="true" class="anchor-heading icon-link" href="#基于事件的并发"></a>基于事件的并发</h2>
<p>node.js</p>
<h3 id="事件循环"><a aria-hidden="true" class="anchor-heading icon-link" href="#事件循环"></a>事件循环</h3>
<ul>
<li>select(poll)</li>
<li>异步 I/O</li>
<li>状态管理</li>
</ul>