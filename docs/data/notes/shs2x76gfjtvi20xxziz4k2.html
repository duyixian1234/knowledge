<h1 id="设计模式"><a aria-hidden="true" class="anchor-heading icon-link" href="#设计模式"></a>设计模式</h1>
<h2 id="设计模式-1"><a aria-hidden="true" class="anchor-heading icon-link" href="#设计模式-1"></a>设计模式</h2>
<blockquote>
<p>设计模式是软件设计中常见问题的典型解决方案。每个模式就像一张蓝图，你可以通过对其进行定制来解决代码中的特定设计问题。</p>
</blockquote>
<h3 id="设计模式与库"><a aria-hidden="true" class="anchor-heading icon-link" href="#设计模式与库"></a>设计模式与库</h3>
<blockquote>
<p>设计模式与方法或库的使用方式不同， 你很难直接在自己的程序中套用某个设计模式。 模式并不是一段特定的代码， 而是解决特定问题的一般性概念。 你可以根据模式来实现符合自己程序实际所需的解决方案。</p>
</blockquote>
<h3 id="设计模式与算法"><a aria-hidden="true" class="anchor-heading icon-link" href="#设计模式与算法"></a>设计模式与算法</h3>
<blockquote>
<p>人们常常会混淆模式和算法， 因为两者在概念上都是已知特定问题的典型解决方案。 但算法总是明确定义达成特定目标所需的一系列步骤， 而模式则是对解决方案的更高层次描述。 同一模式在两个不同程序中的实现代码可能会不一样。</p>
<p>算法更像是菜谱： 提供达成目标的明确步骤。 而模式更像是蓝图： 你可以看到最终的结果和模式的功能， 但需要自己确定实现步骤。</p>
</blockquote>
<h3 id="设计模式的优势"><a aria-hidden="true" class="anchor-heading icon-link" href="#设计模式的优势"></a>设计模式的优势</h3>
<blockquote>
<ul>
<li>设计模式是针对软件设计中常见问题的工具箱, 其中的工具就是各种<strong>经过实践验证的解决方案</strong>。 即使你从未遇到过这些问题, 了解模式仍然非常有用, 因为它能指导你如何使用面向对象的设计原则来解决各种问题。</li>
<li>设计模式定义了一种让你和团队成员能够更高效沟通的通用语言。 你只需说“<strong>哦, 这里用单例就可以了</strong>”, 所有人都会理解这条建议背后的想法。 只要知晓模式及其名称, 你就无需解释什么是单例。</li>
</ul>
</blockquote>
<h3 id="关于设计模式的争议"><a aria-hidden="true" class="anchor-heading icon-link" href="#关于设计模式的争议"></a>关于设计模式的争议</h3>
<h4 id="一种针对不完善编程语言的蹩脚解决方案"><a aria-hidden="true" class="anchor-heading icon-link" href="#一种针对不完善编程语言的蹩脚解决方案"></a>一种针对不完善编程语言的蹩脚解决方案</h4>
<blockquote>
<p>通常当所选编程语言或技术缺少必要的抽象功能时，人们才需要设计模式。在这种情况下，模式是一种可为语言提供更优功能的蹩脚解决方案。</p>
<p>例如，策略模式在绝大部分现代编程语言中可以简单地使用匿名（lamb­da）函数来实现。</p>
</blockquote>
<h4 id="低效的解决方案"><a aria-hidden="true" class="anchor-heading icon-link" href="#低效的解决方案"></a>低效的解决方案</h4>
<blockquote>
<p>模式试图将已经广泛使用的方式系统化。许多人会将这样的统一化认为是某种教条，他们会 “全心全意” 地实施这样的模式， 而不会根据项目的实际情况对其进行调整。</p>
</blockquote>
<h4 id="不当使用"><a aria-hidden="true" class="anchor-heading icon-link" href="#不当使用"></a>不当使用</h4>
<blockquote>
<p>如果你只有一把铁锤， 那么任何东西看上去都像是钉子。</p>
<p>这个问题常常会给初学模式的人们带来困扰：在学习了某个模式后，他们会在所有地方使用该模式，即便是在较为简单的代码也能胜任的地方也是如此。</p>
</blockquote>
<h2 id="分类"><a aria-hidden="true" class="anchor-heading icon-link" href="#分类"></a>分类</h2>
<h3 id="创建型模式"><a aria-hidden="true" class="anchor-heading icon-link" href="#创建型模式"></a>创建型模式</h3>
<p><a href="/notes/21aud0t5f5hq4ahia694mc2">创建型模式</a>提供创建对象的机制， 增加已有代码的灵活性和可复用性。</p>
<h3 id="结构型模式"><a aria-hidden="true" class="anchor-heading icon-link" href="#结构型模式"></a>结构型模式</h3>
<p><a href="/notes/mi2yzsm134w3za8f9p0x1dx">结构型模式</a>介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。</p>
<h3 id="行为模式"><a aria-hidden="true" class="anchor-heading icon-link" href="#行为模式"></a>行为模式</h3>
<p><a href="/notes/b0yhqaf6sz4d7ef6llmskjj">行为型模式</a>负责对象间的高效沟通和职责委派。</p>
<h2 id="参考"><a aria-hidden="true" class="anchor-heading icon-link" href="#参考"></a>参考</h2>
<p></p><p></p><div class="portal-container">
<div class="portal-head">
<div class="portal-backlink">
<div class="portal-title">From <span class="portal-text-title">Links</span></div>
<a href="/notes/ahciw5hvh28k50dw13ql1b4" class="portal-arrow">Go to text <span class="right-arrow">→</span></a>
</div>
</div>
<div id="portal-parent-anchor" class="portal-parent" markdown="1">
<div class="portal-parent-fader-top"></div>
<div class="portal-parent-fader-bottom"></div><h2 id="设计模式-2"><a aria-hidden="true" class="anchor-heading icon-link" href="#设计模式-2"></a>设计模式</h2>
<ul>
<li><a href="https://refactoringguru.cn/design-patterns">设计模式</a></li>
</ul>
</div></div><p></p><p></p>
<hr>
<strong>Children</strong>
<ol>
<li><a href="/notes/21aud0t5f5hq4ahia694mc2">创建型模式</a></li>
<li><a href="/notes/mi2yzsm134w3za8f9p0x1dx">结构型模式</a></li>
<li><a href="/notes/b0yhqaf6sz4d7ef6llmskjj">行为型模式</a></li>
</ol>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/">个人知识库</a></li>
<li><a href="/notes/fl710h5oacxibkom399srh1">软件设计</a></li>
</ul>